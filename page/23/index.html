<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="haitian的博客">
<meta property="og:url" content="http://yoursite.com/page/23/index.html">
<meta property="og:site_name" content="haitian的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="haitian的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/23/"/>





  <title>haitian的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">haitian的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">为了更好的生活而奋斗!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/how-to-mount-a-xen-image/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/how-to-mount-a-xen-image/" itemprop="url">How to mount a xen image ?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:34:43+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1. First you need to find out the partitions and the startsector of partitions:</p>
<p>de&gt;[root@xen rruban]# file rheltest.img<br>rheltest.img: x86 boot sector, GRand Unified Bootloader (0.94);<br>partition 1: ID=0x83, active, starthead 1, startsector 63, 208782 sectors;<br>partition 2: ID=0x8e, starthead 0, startsector 208845, 3871665 sectors, code offset 0x48de&gt;</p>
<p>There are 3 partitions inside the image file. The startsector of each partition is also listed. Boot partition will have start sector 63.</p>
<p>2. Now you need to get the sector size:</p>
<p>de&gt;[root@xen]fdisk -lu rheltest.imgde&gt;</p>
<p>de&gt;<br>Disk rheltest.img: 0 MB, 0 bytes 255 heads, 63 sectors/track, 0 cylinders, total 0 sectors<br>Units = sectors of 1 <em> 512 = 512 bytes<br>Device Boot             Start         End      Blocks   Id  System<br>rheltest.img1   </em>          63      208844      104391   83  Linux<br>rheltest.img2          208845     4080509     1935832+  8e  Linux LVM<br>de&gt;</p>
<p>The above shows the sector byte size is 512 byte.</p>
<p>3. To calculating the offset: offset = start_sector x sector_byte_size.</p>
<p>The startsector is 63 for the first partition, therefore the first partition offset is: 63x512=32256</p>
<p>4. Finally, to mount the xen image, use:</p>
<p>de&gt;mount -o loop,offset=32256  test.img /foldernamede&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/mplayer-prohibits-pop-up-errors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/mplayer-prohibits-pop-up-errors/" itemprop="url">mplayer禁止弹出错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:34:07+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用mplayer播放视频时，放了全部的解码后，发现放rm文件时还缺少一个，到windows下去复制过来，drvc.dll,基本上就所有的都可以播 放了，但有些可以播放，但会出现 错误，所有就加上参数-really-quiet,就可以忽略了，可以编辑菜单，修改启动的参数就可以gmplayer -really-quiet %F</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/super-detailed-tcpdump-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/super-detailed-tcpdump-usage/" itemprop="url">超级详细Tcpdump 的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:33:20+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>超级详细Tcpdump 的用法</p>
<p>第 一种是关于类型的关键字，主要包括host，net，port， 例如 host 210.27.48.2，指明 210.27.48.2是一台主机，net 202.0.0.0 指明 202.0.0.0是一个网络地址，port 23 指明端口号是23.如果没有指定类型，缺省的类型是host.</p>
<p>　　第二种是确定传输方向的关键字，主要包括src ， dst ，dst or src， dst and src ，这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0 .如果没有指明方向关键字，则缺省是src or dst关键字。</p>
<p>　　第三种是协议的关键字，主要包括 fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI（分布式光纤数据接口网 络）上的特定 的网络协议，实际上它是”ether”的别名，fddi和ether具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和 分析。其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump将会监听所有协议的信息包。</p>
<p>　　除了这三 种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less，greater，还有三种逻辑运算，取非运算是 ‘not ‘ ‘！ ‘， 与运算是’and’，’&amp;&amp;’；或运算 是’or’ ，’││’；这些关键字可以组合起来构成强大的组合条件来满足人们的需要，下面举几个例子来说明。</p>
<p>　　普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。</p>
<p>　　# tcpdump</p>
<p>　　tcpdump： listening on fxp0</p>
<p>　　11：58：47.873028 202.102.245.40.netbios-ns &gt; 202.102.245.127.netbios-ns： udp 50</p>
<p>　　11：58：47.974331 0：10：7b：8：3a：56 &gt; 1：80：c2：0：0：0 802.1d ui/C len=43</p>
<p>　　0000 0000 0080 0000 1007 cf08 0900 0000</p>
<p>　　0e80 0000 902b 4695 0980 8701 0014 0002</p>
<p>　　000f 0000 902b 4695 0008 00</p>
<p>　　11：58：48.373134 0：0：e8：5b：6d：85 &gt; Broadcast sap e0 ui/C len=97</p>
<p>　　ffff 0060 0004 ffff ffff ffff ffff ffff</p>
<p>　　0452 ffff ffff 0000 e85b 6d85 4008 0002</p>
<p>　　0640 4d41 5354 4552 5f57 4542 0000 0000</p>
<p>　　0000 00</p>
<p>　　使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，</p>
<p>　　使用-c参数指定要监听的数据包数量，</p>
<p>　　使用-w参数指定将监听到的数据包写入文件中保存</p>
<p>　　A想要截获所有210.27.48.1 的主机收到的和发出的所有的数据包：</p>
<p>　　#tcpdump host 210.27.48.1</p>
<p>　　B想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令：（在命令行中适用　括号时，一定要</p>
<p>　　#tcpdump host 210.27.48.1 and （210.27.48.2 or 210.27.48.3 ）</p>
<p>　　C如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>
<p>　　#tcpdump ip host 210.27.48.1 and ！ 210.27.48.2</p>
<p>　　D如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>
<p>　　#tcpdump tcp port 23 host 210.27.48.1</p>
<p>　　E 对本机的udp 123 端口进行监视 123 为ntp的服务端口</p>
<p>　　# tcpdump udp port 123</p>
<p>　　F 系统将只对名为hostname的主机的通信数据包进行监视。主机名可以是本地主机，也可以是网络上的任何一台计算机。下面的命令可以读取主机hostname发送的所有数据：</p>
<p>　　#tcpdump -i eth0 src host hostname</p>
<p>　　G 下面的命令可以监视所有送到主机hostname的数据包：</p>
<p>　　#tcpdump -i eth0 dst host hostname</p>
<p>　　H  我们还可以监视通过指定网关的数据包：</p>
<p>　　#tcpdump -i eth0 gateway Gatewayname</p>
<p>　　I 如果你还想监视编址到指定端口的TCP或UDP数据包，那么执行以下命令：</p>
<p>　　#tcpdump -i eth0 host hostname and port 80</p>
<p>　　J 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包</p>
<p>　　，使用命令：</p>
<p>　　#tcpdump ip host 210.27.48.1 and ！ 210.27.48.2</p>
<p>　　K 想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令</p>
<p>　　：（在命令行中适用　括号时，一定要</p>
<p>　　#tcpdump host 210.27.48.1 and （210.27.48.2 or 210.27.48.3 ）</p>
<p>　　L 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>
<p>　　#tcpdump ip host 210.27.48.1 and ！ 210.27.48.2</p>
<p>　　M 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>
<p>　　#tcpdump tcp port 23 host 210.27.48.1</p>
<p>　　第三种是协议的关键字，主要包括fddi，ip ，arp，rarp，tcp，udp等类型</p>
<p>　　除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less，</p>
<p>　　greater，还有三种逻辑运算，取非运算是 ‘not ‘ ‘！ ‘， 与运算是’and’，’&amp;&amp;’；或运算 是’o</p>
<p>　　r’ ，’||’；</p>
<p>　　第二种是确定传输方向的关键字，主要包括src ， dst ，dst or src， dst and src ，</p>
<p>　　如果我们只需要列出送到80端口的数据包，用dst port；如果我们只希望看到返回80端口的数据包，用src port.</p>
<p>　　#tcpdump –i eth0 host hostname and dst port 80  目的端口是80</p>
<p>　　或者</p>
<p>　　#tcpdump –i eth0 host hostname and src port 80  源端口是80  一般是提供http的服务的主机</p>
<p>　　如果条件很多的话  要在条件之前加and 或 or 或 not</p>
<p>　　#tcpdump -i eth0 host ！ 211.161.223.70 and ！ 211.161.223.71 and dst port 80</p>
<p>　　如果在ethernet 使用混杂模式 系统的日志将会记录</p>
<p>　　May  7 20：03：46 localhost kernel： eth0： Promiscuous mode enabled.</p>
<p>　　May  7 20：03：46 localhost kernel： device eth0 entered promiscuous mode</p>
<p>　　May  7 20：03：57 localhost kernel： device eth0 left promiscuous mode</p>
<p>　 　tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的 解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/linux-memory-debugging-tool-valgrind-uses-preliminary-exploration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/linux-memory-debugging-tool-valgrind-uses-preliminary-exploration/" itemprop="url">Linux 内存调试工具- Valgrind 使用初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:30:52+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Valgrind 是在linux系统下开发应用程序时用于调试内存问题的工具。它尤其擅长发现内存管理的问题，它可以检查程序运行时的内存泄漏问题。</p>
<p>   它的官方网址是 <a href="http://www.valgrind.org/" target="_blank" rel="noopener">http://www.valgrind.org/</a></p>
<p>   下载最新版本的Valgrind，目前是3.2.0。 wget <a href="http://www.valgrind.org/downloads/valkyrie-1.2.0.tar.bz2" target="_blank" rel="noopener">http://www.valgrind.org/downloads/valkyrie-1.2.0.tar.bz2</a></p>
<p>   执行常规的安装步骤：./confgure &amp;&amp; make &amp;&amp; make install。注意： 系统必须安装QT的开发包。即便这样在make 时还是出现qplatformdefs.h这个文件找不到的情况，导致make失败。查找系统中的qplatformdefs.h 之后，发现没有存在于qt的标准头文件目录/usr/lib/qt-3.3/include。如是将/usr/lib/qt-3.3/mkspecs /linux-g++/ 目录下该头文件复制标准头文件目录，重新make ，后面一切OK。</p>
<p>初次使用</p>
<pre><code>编译如下代码:  gcc -Wall example.c -g -o example 
</code></pre><p>#include &lt;stdlib.h&gt;  </p>
<p>void f(void)<br>{<br>   int<em> x = malloc(10 </em> sizeof(int));<br>   x[10] = 0;        // problem 1: heap block overrun<br>}                    // problem 2: memory leak – x not freed  </p>
<p>int main(void)<br>{<br>     f();<br>     return 0;<br>}</p>
<pre><code>注意：gcc 的-g 选项让Valgrind调试输出时指出相应信息的代码所在的行号。
</code></pre><p>valgrind –tool=memcheck –leak-check=yes ./example</p>
<p>==6742== Memcheck, a memory error detector for x86-linux.<br>==6742== Copyright (C) 2002-2004, and GNU GPL’d, by Julian Seward et al.<br>==6742== Using valgrind-2.2.0, a program supervision framework for x86-linux.<br>==6742== Copyright (C) 2000-2004, and GNU GPL’d, by Julian Seward et al.<br>==6742== For more details, rerun with: -v<br>==6742==<br>==6742== Invalid write of size 4<br>==6742==    at 0x8048384: f (example.c:6)<br>==6742==    by 0x80483AC: main (example.c:12)<br>==6742==  Address 0x1B908050 is 0 bytes after a block of size 40 alloc’d<br>==6742==    at 0x1B904984: malloc (vg_replace_malloc.c:131)<br>==6742==    by 0x8048377: f (example.c:5)<br>==6742==    by 0x80483AC: main (example.c:12)<br>==6742==<br>==6742== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 12 from 1)<br>==6742== malloc/free: in use at exit: 40 bytes in 1 blocks.<br>==6742== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.<br>==6742== For counts of detected errors, rerun with: -v<br>==6742== searching for pointers to 1 not-freed blocks.<br>==6742== checked 1360800 bytes.<br>==6742==<br>==6742==<br>==6742== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1<br>==6742==    at 0x1B904984: malloc (vg_replace_malloc.c:131)<br>==6742==    by 0x8048377: f (example.c:5)<br>==6742==    by 0x80483AC: main (example.c:12)<br>==6742==<br>==6742== LEAK SUMMARY:<br>==6742==    definitely lost: 40 bytes in 1 blocks.<br>==6742==    possibly lost:   0 bytes in 0 blocks.<br>==6742==    still reachable: 0 bytes in 0 blocks.<br>==6742==         suppressed: 0 bytes in 0 blocks.<br>==6742== Reachable blocks (those to which a pointer was found) are not shown.<br>==6742== To see them, rerun with: –show-reachable=yes</p>
<p>   上面的C程序存在两个错误：1. 数组下标越界；2. 分配的内存没有释放，存在内存泄露的问题。对于错误1，看Valgrind的调试信息片断</p>
<p>==6742== Invalid write of size 4<br>==6742==    at 0x8048384: f (example.c:6)<br>==6742==    by 0x80483AC: main (example.c:12)<br>==6742==  Address 0x1B908050 is 0 bytes after a block of size 40 alloc’d<br>==6742==    at 0x1B904984: malloc (vg_replace_malloc.c:131)<br>==6742==    by 0x8048377: f (example.c:5)</p>
<p>对于错误2，看这个</p>
<p>==6742== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.</p>
<p>……</p>
<p>==6742== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1<br>==6742==    at 0x1B904984: malloc (vg_replace_malloc.c:131)<br>==6742==    by 0x8048377: f (example.c:5)<br>==6742==    by 0x80483AC: main (example.c:12)</p>
<p>相关链接：</p>
<p>   <a href="http://www.valgrind.org/docs/manual/quick-start.html" target="_blank" rel="noopener">http://www.valgrind.org/docs/manual/quick-start.html</a></p>
<p>   <a href="http://www-128.ibm.com/developerworks/cn/linux/l-pow-debug/" target="_blank" rel="noopener">http://www-128.ibm.com/developerworks/cn/linux/l-pow-debug/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/nmap-uses-a-detailed-solution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/nmap-uses-a-detailed-solution/" itemprop="url">nmap使用详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:30:15+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>nmap是一个网络探测和安全扫描程序， 系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap支持很多扫描技术，例如：UDP、TCP connect()、TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。从扫描类型一节可以得到细节。nmap还提供了一些高级的特征，例如：通过TCP/IP协议栈特征探测操作系统类 型，秘密扫描，动态延时和重传计算，并行扫描，通过并行ping扫描探测关闭的主机，诱饵扫描，避开端口过滤检测，直接RPC扫描(无须端口影射)，碎片 扫描，以及灵活的目标和端口设定.<br>--------------------------------------------------------------------------------<br>1.名称</p>
<p>nmap-网络探测和安全扫描工具</p>
<p>2.语法</p>
<p>nmap [Scan Type(s)] [Options]</p>
<p>3.描述</p>
<p>　 　nmap是一个网络探测和安全扫描程 序，系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap支持很多扫描技术，例如：UDP、TCP connect()、TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。从扫描类型一节可以得到细节。nmap还提供了一些高级的特征，例如：通过TCP/IP协议栈特征探测操作系统类 型，秘密扫描，动态延时和重传计算，并行扫描，通过并行ping扫描探测关闭的主机，诱饵扫描，避开端口过滤检测，直接RPC扫描(无须端口影射)，碎片 扫描，以及灵活的目标和端口设定。</p>
<p>　　为了提高nmap在non-root状态下的性能，软件的设计者付出了很大的努力。很不幸，一些内核界面(例如raw socket)需要在root状态下使用。所以应该尽可能在root使用nmap。</p>
<p>　 　nmap运行通常会得到被扫描主机端 口的列表。nmap总会给出well known端口的服务名(如果可能)、端口号、状态和协议等信息。每个端口的状态有：open、filtered、unfiltered。open状态意 味着目标主机能够在这个端口使用accept()系统调用接受连接。filtered状态表示：防火墙、包过滤和其它的网络安全软件掩盖了这个端口，禁止 nmap探测其是否打开。unfiltered表示：这个端口关闭，并且没有防火墙/包过滤软件来隔离nmap的探测企图。通常情况下，端口的状态基本都 是unfiltered状态，只有在大多数被扫描的端口处于filtered状态下，才会显示处于unfiltered状态的端口。</p>
<p>　　根据使用的功能选项，nmap也可以报告远程主机的下列特征：使用的操作系统、TCP序列、运行绑定到每个端口上的应用程序的用户名、DNS名、主机地址是否是欺骗地址、以及其它一些东西。</p>
<p>4.功能选项</p>
<p>　　功能选项可以组合使用。一些功能选项只能够在某种扫描模式下使用。nmap会自动识别无效或者不支持的功能选项组合，并向用户发出警告信息。</p>
<p>　　如果你是有经验的用户，可以略过结尾的示例一节。可以使用nmap -h快速列出功能选项的列表。</p>
<p>4.1 扫描类型</p>
<p>　　-sT<br>　 　TCP connect()扫描：这是最基本的TCP扫描方式。connect()是一种系统调用，由操作系统提供，用来打开一个连接。如果目标端口有程序监听， connect()就会成功返回，否则这个端口是不可达的。这项技术最大的优点是，你勿需root权限。任何UNIX用户都可以自由使用这个系统调用。这 种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。<br>　　-sS<br>　　TCP同步扫描(TCP SYN)：因为不必全部打开一个TCP连接，所以这项技术通常称为半开扫描(half-open)。你可以发出一个TCP同步包(SYN)，然后等待回 应。如果对方返回SYN|ACK(响应)包就表示目标端口正在监听；如果返回RST数据包，就表示目标端口没有监听程序；如果收到一个SYN|ACK包， 源主机就会马上发出一个RST(复位)数据包断开和目标主机的连接，这实际上有我们的操作系统内核自动完成的。这项技术最大的好处是，很少有系统能够把这 记入系统日志。不过，你需要root权限来定制SYN数据包。<br>　　-sF -sF -sN<br>　　秘密FIN数据包扫描、圣诞树 (Xmas Tree)、空(Null)扫描模式：即使SYN扫描都无法确定的情况下使用。一些防火墙和包过滤软件能够对发送到被限制端口的SYN数据包进行监视，而 且有些程序比如synlogger和courtney能够检测那些扫描。这些高级的扫描方式可以逃过这些干扰。这些扫描方式的理论依据是：关闭的端口需要 对你的探测包回应RST包，而打开的端口必需忽略有问题的包(参考RFC 793第64页)。FIN扫描使用暴露的FIN数据包来探测，而圣诞树扫描打开数据包的FIN、URG和PUSH标志。不幸的是，微软决定完全忽略这个标 准，另起炉灶。所以这种扫描方式对Windows95/NT无效。不过，从另外的角度讲，可以使用这种方式来分别两种不同的平台。如果使用这种扫描方式可 以发现打开的端口，你就可以确定目标注意运行的不是Windows系统。如果使用-sF、-sX或者-sN扫描显示所有的端口都是关闭的，而使用SYN扫 描显示有打开的端口，你可以确定目标主机可能运行的是Windwos系统。现在这种方式没有什么太大的用处，因为nmap有内嵌的操作系统检测功能。还有 其它几个系统使用和windows同样的处理方式，包括Cisco、BSDI、HP/UX、MYS、IRIX。在应该抛弃数据包时，以上这些系统都会从打 开的端口发出复位数据包。<br>　　-sP<br>　　ping扫描：有时你只是想知道此时网络上哪些主机正在运行。通过向你指定的网络内的每个 IP地址发送ICMP echo请求数据包，nmap就可以完成这项任务。如果主机正在运行就会作出响应。不幸的是，一些站点例如：microsoft.com阻塞ICMP echo请求数据包。然而，在默认的情况下nmap也能够向80端口发送TCP ack包，如果你收到一个RST包，就表示主机正在运行。nmap使用的第三种技术是：发送一个SYN包，然后等待一个RST或者SYN/ACK包。对于 非root用户，nmap使用connect()方法。<br>　　在默认的情况下(root用户)，nmap并行使用ICMP和ACK技术。<br>　　注意，nmap在任何情况下都会进行ping扫描，只有目标主机处于运行状态，才会进行后续的扫描。如果你只是想知道目标主机是否运行，而不想进行其它扫描，才会用到这个选项。<br>　　-sU<br>　　UDP扫描：如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用这种扫描方法。nmap首先向目标主机的每个端口发出一个0字节的UDP包，如果我们收到端口不可达的ICMP消息，端口就是关闭的，否则我们就假设它是打开的。<br>　 　有些人可能会想UDP扫描是没有什么意思的。但是，我经常会想到最近出现的solaris rpcbind缺陷。rpcbind隐藏在一个未公开的UDP端口上，这个端口号大于32770。所以即使端口111(portmap的众所周知端口号) 被防火墙阻塞有关系。但是你能发现大于30000的哪个端口上有程序正在监听吗?使用UDP扫描就能！cDc Back Orifice的后门程序就隐藏在Windows主机的一个可配置的UDP端口中。不考虑一些通常的安全缺陷，一些服务例如:snmp、tftp、NFS 使用UDP协议。不幸的是，UDP扫描有时非常缓慢，因为大多数主机限制ICMP错误信息的比例(在RFC1812中的建议)。例如，在Linux内核中 (在net/ipv4/icmp.h文件中)限制每4秒钟只能出现80条目标不可达的ICMP消息，如果超过这个比例，就会给1/4秒钟的处罚。 solaris的限制更加严格，每秒钟只允许出现大约2条ICMP不可达消息，这样，使扫描更加缓慢。nmap会检测这个限制的比例，减缓发送速度，而不 是发送大量的将被目标主机丢弃的无用数据包。<br>　　不过Micro$oft忽略了RFC1812的这个建议，不对这个比例做任何的限制。所以我们可以能够快速扫描运行Win95/NT的主机上的所有65K个端口。<br>　　-sA<br>　　ACK扫描：这项高级的扫描方法通常用来穿过防火墙的规则集。通常情况下，这有助于确定一个防火墙是功能比较完善的或者是一个简单的包过滤程序，只是阻塞进入的SYN包。<br>　 　这种扫描是向特定的端口发送ACK包(使用随机的应答/序列号)。如果返回一个RST包，这个端口就标记为unfiltered状态。如果什么都没有返 回，或者返回一个不可达ICMP消息，这个端口就归入filtered类。注意，nmap通常不输出unfiltered的端口，所以在输出中通常不显示 所有被探测的端口。显然，这种扫描方式不能找出处于打开状态的端口。<br>　　-sW<br>　　对滑动窗口的扫描：这项高级扫描技术非常类似于 ACK扫描，除了它有时可以检测到处于打开状态的端口，因为滑动窗口的大小是不规则的，有些操作系统可以报告其大小。这些系统至少包括：某些版本的 AIX、Amiga、BeOS、BSDI、Cray、Tru64 UNIX、DG/UX、OpenVMS、Digital UNIX、OpenBSD、OpenStep、QNX、Rhapsody、SunOS 4.x、Ultrix、VAX、VXWORKS。从nmap-hackers邮件3列表的文档中可以得到完整的列表。<br>　　-sR<br>　 　RPC扫描。这种方法和nmap的其它不同的端口扫描方法结合使用。选择所有处于打开状态的端口向它们发出SunRPC程序的NULL命令，以确定它们 是否是RPC端口，如果是，就确定是哪种软件及其版本号。因此你能够获得防火墙的一些信息。诱饵扫描现在还不能和RPC扫描结合使用。<br>　　-b<br>　 　FTP反弹攻击(bounce attack):FTP协议(RFC 959)有一个很有意思的特征，它支持代理FTP连接。也就是说，我能够从evil.com连接到FTP服务器target.com，并且可以要求这台 FTP服务器为自己发送Internet上任何地方的文件！1985年，RFC959完成时，这个特征就能很好地工作了。然而，在今天的Internet 中，我们不能让人们劫持FTP服务器，让它向Internet上的任意节点发送数据。如同Hobbit在1995年写的文章中所说的，这个协议”能够用来 做投递虚拟的不可达邮件和新闻，进入各种站点的服务器,填满硬盘，跳过防火墙，以及其它的骚扰活动，而且很难进行追踪”。我们可以使用这个特征，在一台代 理FTP服务器扫描TCP端口。因此，你需要连接到防火墙后面的一台FTP服务器，接着进行端口扫描。如果在这台FTP服务器中有可读写的目录，你还可以 向目标端口任意发送数据(不过nmap不能为你做这些)。<br>　　传递给-b功能选项的参数是你要作为代理的FTP服务器。语法格式为：<br>　　-b username:password@server:port。<br>　　除了server以外，其余都是可选的。如果你想知道什么服务器有这种缺陷，可以参考我在Phrack 51发表的文章。还可以在nmap的站点得到这篇文章的最新版本。  </p>
<p>4.2 通用选项</p>
<p>　　这些内容不是必需的，但是很有用。</p>
<p>　　-P0<br>　　在扫描之前，不必ping主机。有些网络的防火墙不允许ICMP echo请求穿过，使用这个选项可以对这些网络进行扫描。microsoft.com就是一个例子，因此在扫描这个站点时，你应该一直使用-P0或者-PT 80选项。<br>　　-PT<br>　 　扫描之前，使用TCP ping确定哪些主机正在运行。nmap不是通过发送ICMP echo请求包然后等待响应来实现这种功能，而是向目标网络(或者单一主机)发出TCP ACK包然后等待回应。如果主机正在运行就会返回RST包。只有在目标网络/主机阻塞了ping包，而仍旧允许你对其进行扫描时，这个选项才有效。对于非 root用户，我们使用connect()系统调用来实现这项功能。使用-PT &lt;端口号&gt;来设定目标端口。默认的端口号是80，因为这个端口通常不会被过滤。<br>　　-PS<br>　　对于root用户，这个选项让nmap使用SYN包而不是ACK包来对目标主机进行扫描。如果主机正在运行就返回一个RST包(或者一个SYN/ACK包)。<br>　　-PI<br>　 　设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。使用这个选项让nmap发现正在运行的主机的同时，nmap也会对你的直接子网广播地址进行观察。直接子网广 播地址一些外部可达的IP地址，把外部的包转换为一个内向的IP广播包，向一个计算机子网发送。这些IP广播包应该删除，因为会造成拒绝服务攻击(例如 smurf)。<br>　　-PB<br>　　这是默认的ping扫描选项。它使用ACK(-PT)和ICMP(-PI)两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。<br>　　-O<br>　 　这个选项激活对TCP/IP指纹特征(fingerprinting)的扫描，获得远程主机的标志。换句话说，nmap使用一些技术检测目标主机操作系 统网络协议栈的特征。nmap使用这些信息建立远程主机的指纹特征，把它和已知的操作系统指纹特征数据库做比较，就可以知道目标主机操作系统的类型。<br>　　-I<br>　 　这个选项打开nmap的反向标志扫描功能。Dave Goldsmith 1996年向bugtap发出的邮件注意到这个协议，ident协议(rfc 1413)允许使用TCP连接给出任何进程拥有者的用户名，即使这个进程并没有初始化连接。例如，你可以连接到HTTP端口，接着使用identd确定这 个服务器是否由root用户运行。这种扫描只能在同目标端口建立完全的TCP连接时(例如：-sT扫描选项)才能成功。使用-I选项是，远程主机的 identd精灵进程就会查询在每个打开的端口上监听的进程的拥有者。显然，如果远程主机没有运行identd程序，这种扫描方法无效。<br>　　-f<br>　 　这个选项使nmap使用碎片IP数据包发送SYN、FIN、XMAS、NULL。使用碎片数据包增加包过滤、入侵检测系统的难度，使其无法知道你的企 图。不过，要慎重使用这个选项！有些程序在处理这些碎片包时会有麻烦，我最喜欢的嗅探器在接受到碎片包的头36个字节时，就会发生 segmentation faulted。因此，在nmap中使用了24个字节的碎片数据包。虽然包过滤器和防火墙不能防这种方法，但是有很多网络出于性能上的考虑，禁止数据包的 分片。<br>　　注意这个选项不能在所有的平台上使用。它在Linux、FreeBSD、OpenBSD以及其它一些UNIX系统能够很好工作。<br>　　-v<br>　　冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。使用这个选项，你可以得到事半功倍的效果。使用-d选项可以得到更加详细的信息。<br>　　-h<br>　　快速参考选项。<br>　　-oN<br>　　把扫描结果重定向到一个可读的文件logfilename中。<br>　　-oM<br>　 　把扫描结果重定向到logfilename文件中，这个文件使用主机可以解析的语法。你可以使用-oM -来代替logfilename，这样输出就被重定向到标准输出stdout。在这种情况下，正常的输出将被覆盖，错误信息荏苒可以输出到标准错误 stderr。要注意，如果同时使用了-v选项，在屏幕上会打印出其它的信息。<br>　　-oS 　　 thIs l0gz th3 r3suLtS of YouR ScanZ iN a s| 　　THe fiL3 U sPecfy 4s an arGuMEnT! U kAn gIv3 the 4rgument -<br>　　(wItHOUt qUOteZ) to sh00t output iNT0 stDouT!@!! 莫名其妙，下面是我猜着翻译的，相形字？<br>　　把扫描结果重定向到一个文件logfilename中，这个文件使用一种”黑客方言”的语法形式(作者开的玩笑?)。同样，使用-oS -就会把结果重定向到标准输出上。<br>　　-resume<br>　 　某个网络扫描可能由于control-C或者网络损失等原因被中断，使用这个选项可以使扫描接着以前的扫描进行。logfilename是被取消扫描的 日志文件，它必须是可读形式或者机器可以解析的形式。而且接着进行的扫描不能增加新的选项，只能使用与被中断的扫描相同的选项。nmap会接着日志文件中 的最后一次成功扫描进行新的扫描。<br>　　-iL<br>　　从inputfilename文件中读取扫描的目标。在这个文件中要有一个主机或者网络的列表，由空格键、制表键或者回车键作为分割符。如果使用-iL -，nmap就会从标准输入stdin读取主机名字。你可以从指定目标一节得到更加详细的信息。<br>　　-iR<br>　　让nmap自己随机挑选主机进行扫描。<br>　　-p &lt;端口范围&gt;<br>　 　这个选项让你选择要进行扫描的端口号的范围。例如，-p 23表示：只扫描目标主机的23号端口。-p 20-30,139,60000-表示：扫描20到30号端口，139号端口以及所有大于60000的端口。在默认情况下，nmap扫描从1到1024号 以及nmap-services文件(如果使用RPM软件包，一般在/usr/share/nmap/目录中)中定义的端口列表。<br>　　-F<br>　　快速扫描模式，只扫描在nmap-services文件中列出的端口。显然比扫描所有65535个端口要快。<br>　　-D<br>　 　使用诱饵扫描方法对目标网络/主机进行扫描。如果nmap使用这种方法对目标网络进行扫描，那么从目标主机/网络的角度来看，扫描就象从其它主机 (decoy1,等)发出的。从而，即使目标主机的IDS(入侵检测系统)对端口扫描发出报警，它们也不可能知道哪个是真正发起扫描的地址，哪个是无辜 的。这种扫描方法可以有效地对付例如路由跟踪、response-dropping等积极的防御机制，能够很好地隐藏你的IP地址。<br>　　每个 诱饵主机名使用逗号分割开，你也可以使用ME选项，它代表你自己的主机，和诱饵主机名混杂在一起。如果你把ME放在第六或者更靠后的位置，一些端口扫描检 测软件几乎根本不会显示你的IP地址。如果你不使用ME选项，nmap会把你的IP地址随机夹杂在诱饵主机之中。<br>　　注意:你用来作为诱饵的 主机应该正在运行或者你只是偶尔向目标发送SYN数据包。很显然，如果在网络上只有一台主机运行，目标将很轻松就会确定是哪台主机进行的扫描。或许，你还 要直接使用诱饵的IP地址而不是其域名，这样诱饵网络的域名服务器的日志上就不会留下关于你的记录。<br>　　还要注意：一些愚蠢的端口扫描检测软件会拒绝路由试图进行端口扫描的主机。因而，你需要让目标主机和一些诱饵断开连接。如果诱饵是目标主机的网关或者就是其自己时，会给目标主机造成很大问题。所以你需要慎重使用这个选项。<br>　　诱饵扫描既可以在起始的ping扫描也可以在真正的扫描状态下使用。它也可以和-O选项组合使用。<br>　　使用太多的诱饵扫描能够减缓你的扫描速度甚至可能造成扫描结果不正确。同时，有些ISP会把你的欺骗包过滤掉。虽然现在大多数的ISP不会对此进行限制。<br>　　-S &lt;IP_Address&gt;<br>　　在一些情况下，nmap可能无法确定你的源地址(nmap会告诉你)。在这种情况使用这个选项给出你的IP地址。<br>　　在欺骗扫描时，也使用这个选项。使用这个选项可以让目标认为是其它的主机对自己进行扫描。<br>　　-e<br>　　告诉nmap使用哪个接口发送和接受数据包。nmap能够自动对此接口进行检测，如果无效就会告诉你。<br>　　-g<br>　 　设置扫描的源端口。一些天真的防火墙和包过滤器的规则集允许源端口为DNS(53)或者FTP-DATA(20)的包通过和实现连接。显然，如果攻击者 把源端口修改为20或者53，就可以摧毁防火墙的防护。在使用UDP扫描时，先使用53号端口；使用TCP扫描时，先使用20号端口。注意只有在能够使用 这个端口进行扫描时，nmap才会使用这个端口。例如，如果你无法进行TCP扫描，nmap会自动改变源端口，即使你使用了-g选项。<br>　　对于一些扫描，使用这个选项会造成性能上的微小损失，因为我有时会保存关于特定源端口的一些有用的信息。<br>　　-r<br>　　告诉nmap不要打乱被扫描端口的顺序。<br>　　–randomize_hosts<br>　　使nmap在扫描之前，打乱每组扫描中的主机顺序，nmap每组可以扫描最多2048台主机。这样，可以使扫描更不容易被网络监视器发现，尤其和–scan_delay 选项组合使用，更能有效避免被发现。<br>　　-M<br>　　设置进行TCP connect()扫描时，最多使用多少个套接字进行并行的扫描。使用这个选项可以降低扫描速度，避免远程目标宕机。</p>
<p>4.3 适时选项</p>
<p>　　通常，nmap在运行时，能够很好地根据网络特点进行调整。扫描时，nmap会尽量减少被目标检测到的机会，同时尽可能加快扫描速度。然而，nmap默认的适时策略有时候不太适合你的目标。使用下面这些选项，可以控制nmap的扫描timing：</p>
<p>-T<br>　 　设置nmap的适时策略。Paranoid:为了避开IDS的检测使扫描速度极慢，nmap串行所有的扫描，每隔至少5分钟发送 一个包； Sneaky：也差不多，只是数据包的发送间隔是15秒；Polite：不增加太大的网络负载，避免宕掉目标主机，串行每个探测，并且使每个探测有0.4 秒种的间隔；Normal:nmap默认的选项，在不是网络过载或者主机/端口丢失的情况下尽可能快速地扫描；Aggressive:设置5分钟的超时限 制，使对每台主机的扫描时间不超过5分钟，并且使对每次探测回应的等待时间不超过1.5秒钟；b&gt;Insane:只适合快速的网络或者你不在意丢失 某些信息，每台主机的超时限制是75秒，对每次探测只等待0.3秒钟。你也可是使用数字来代替这些模式，例如：-T 0等于-T Paranoid，-T 5等于-T Insane。<br>　　这些适时模式不能下面的适时选项组合使用。<br>–host_timeout<br>　　设置扫描一台主机的时间，以毫秒为单位。默认的情况下，没有超时限制。<br>–max_rtt_timeout<br>　　设置对每次探测的等待时间，以毫秒为单位。如果超过这个时间限制就重传或者超时。默认值是大约9000毫秒。<br>–min_rtt_timeout<br>　　当目标主机的响应很快时，nmap就缩短每次探测的超时时间。这样会提高扫描的速度，但是可能丢失某些响应时间比较长的包。使用这个选项，可以让nmap对每次探测至少等待你指定的时间，以毫秒为单位。<br>–initial_rtt_timeout<br>　　设置初始探测的超时值。一般这个选项只在使用-P0选项扫描有防火墙保护的主机才有用。默认值是6000毫秒。<br>–max_parallelism<br>　　设置最大的并行扫描数量。–max_parallelism 1表示同时只扫描一个端口。这个选项对其它的并行扫描也有效，例如ping sweep, RPC scan。<br>–scan_delay<br>　　设置在两次探测之间，nmap必须等待的时间。这个选项主要用于降低网络的负载。  </p>
<p>4.4 目标设定</p>
<p>　 　在nmap的所有参数中，只有目标参数是必须给出的。其最简单的形式是在命令行直接输入一个主机名或者一个IP地址。如果你希望扫描某个IP地 址的一个子网，你可以在主机名或者IP地址的后面加上/掩码。掩码在0(扫描整个网络)到32(只扫描这个主机)。使用/24扫描C类地址，/16扫描B 类地址。</p>
<p>　　除此之外，nmap还有更加强大的表示方式让你更加灵活地指定IP地址。例如，如果要扫描这个B类网络 128.210.<em>.</em>，你可以使用下面 三种方式来指定这些地址:128.210.<em>.</em>、128.21-.0-255.0-255或者128.210.0.0/16这三种形式是等价的。</p>
<p>5.例子</p>
<p>　　本节将由浅入深地举例说明如何使用nmap。</p>
<p>nmap -v target.example.com<br>扫描主机target.example.com的所有TCP端口。-v打开冗余模式。</p>
<p>nmap -sS -O target.example.com/24<br>发起对target.example.com所在网络上的所有255个IP地址的秘密SYN扫描。同时还探测每台主机操作系统的指纹特征。需要root权限。</p>
<p>nmap -sX -p 22,53,110,143,4564 128.210.*.1-127<br>对B类IP地址128.210中255个可能的8位子网的前半部分发起圣诞树扫描。确定这些系统是否打开了sshd、DNS、pop3d、imapd和4564端口。注意圣诞树扫描对Micro$oft的系统无效，因为其协议栈的TCP层有缺陷。</p>
<p>nmap -v –randomize_hosts -p 80 <em>.</em>.2.3-5<br>只 扫描指定的IP范围，有时用于对这个 Internet进行取样分析。nmap将寻找Internet上所有后两个字节是.2.3、.2.4、.2.5的 IP地址上的WEB服务器。如果你想发现更多有意思的主机，你可以使用127-222，因为在这个范围内有意思的主机密度更大。</p>
<p>host -l company.com | cut -d -f 4 | ./nmap -v -iL -<br>列出company.com网络的所有主机，让nmap进行扫描。注意：这项命令在GNU/Linux下使用。如果在其它平台，你可能要使用 其它的命令/选项</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/mysql-database-dual-machine-hot-standby-configuration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/mysql-database-dual-machine-hot-standby-configuration/" itemprop="url">Mysql 数据库双机热备的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:29:41+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1。mysql数据库没有增量备份的机制，当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制，其实就是把主数据库的所有的数据同时写到备份数据库中。实现mysql数据库的热备份。</p>
<p>2。要想实现双机的热备首先要了解主从数据库服务器的版本的需求。要实现热备mysql的版本都要高于3.2，还有一个基本的原则就是作为从数据库的数据库版本可以高于主服务器数据库的版本，但是不可以低于主服务器的数据库版本。<br>3。设置主数据库服务器：<br>a. 首先查看主服务器的版本是否是支持热备的版本。然后查看my.cnf(类unix)或者my.ini(windows)中mysqld配置块的配置有没有 log-bin(记录数据库更改日志)，因为mysql的复制机制是基于日志的复制机制，所以主服务器一定要支持更改日志才行。然后设置要写入日志的数据 库或者不要写入日志的数据库。这样只有您感兴趣的数据库的更改才写入到数据库的日志中。</p>
<p>server-id=1 //数据库的id这个应该默认是1就不用改动<br>log-bin=log_name //日志文件的名称，这里可以制定日志到别的目录 如果没有设置则默认主机名的一个日志名称<br>binlog-do-db=db_name //记录日志的数据库<br>binlog-ignore-db=db_name //不记录日志的数据库<br>以上的如果有多个数据库用”,”分割开<br>然后设置同步数据库的用户帐号<br>mysql&gt; GRANT REPLICATION SLAVE ON <em>.</em><br>-> TO ‘repl‘@’%.mydomain.com’ IDENTIFIED BY ‘slavepass’;<br>4.0.2以前的版本, 因为不支持REPLICATION 要使用下面的语句来实现这个功能<br>mysql&gt; GRANT FILE ON <em>.</em><br>-> TO ‘repl‘@’%.mydomain.com’ IDENTIFIED BY ‘slavepass’;<br>设置好主服务器的配置文件后重新启动数据库<br>b.锁定现有的数据库并备份现在的数据<br>锁定数据库<br>mysql&gt; FLUSH TABLES WITH READ LOCK;<br>备份数据库有两种办法一种是直接进入到mysql的data目录然后打包你需要备份数据库的文件夹，第二种是使用mysqldump的方式来备份数据库但是要加上”–master-data “ 这个参数，建议使用第一种方法来备份数据库<br>c.查看主服务器的状态<br>mysql&gt; show master statusG;<br>+—————+———-+————–+——————+<br>| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |<br>+—————+———-+————–+——————+<br>| mysql-bin.003 | 73 | test | manual,mysql |<br>+—————+———-+————–+——————+<br>记录File 和 Position 项目的值，以后要用的。<br>d.然后把数据库的锁定打开<br>mysql&gt; UNLOCK TABLES;<br>4。设置从服务器<br>a.首先设置数据库的配置文件<br>server-id=n //设置数据库id默认主服务器是1可以随便设置但是如果有多台从服务器则不能重复。<br>master-host=db-master.mycompany.com //主服务器的IP地址或者域名<br>master-port=3306 //主数据库的端口号<br>master-user=pertinax //同步数据库的用户<br>master-password=freitag //同步数据库的密码<br>master-connect-retry=60 //如果从服务器发现主服务器断掉，重新连接的时间差<br>report-host=db-slave.mycompany.com //报告错误的服务器<br>b.把从主数据库服务器备份出来的数据库导入到从服务器中<br>c.然后启动从数据库服务器，如果启动的时候没有加上”–skip-slave-start”这个参数则进入到mysql中<br>mysql&gt; slave stop; //停止slave的服务<br>d.设置主服务器的各种参数<br>mysql&gt; CHANGE MASTER TO<br>-> MASTER_HOST=’master_host_name’, //主服务器的IP地址<br>-> MASTER_USER=’replication_user_name’, //同步数据库的用户<br>-> MASTER_PASSWORD=’replication_password’, //同步数据库的密码<br>-> MASTER_LOG_FILE=’recorded_log_file_name’, //主服务器二进制日志的文件名(前面要求记住的参数)<br>-> MASTER_LOG_POS=recorded_log_position; //日志文件的开始位置(前面要求记住的参数)<br>e.启动同步数据库的线程<br>mysql&gt; slave start;<br>查看数据库的同步情况吧。如果能够成功同步那就恭喜了！<br>查看主从服务器的状态<br>mysql&gt; SHOW PROCESSLISTG //可以查看mysql的进程看看是否有监听的进程<br>如果日志太大清除日志的步骤如下<br>1.锁定主数据库<br>mysql&gt; FLUSH TABLES WITH READ LOCK;<br>2.停掉从数据库的slave<br>mysql&gt; slave stop;<br>3.查看主数据库的日志文件名和日志文件的position<br>show master status;<br>+—————+———-+————–+——————+<br>| File | Position | Binlog_do_db | Binlog_ignore_db |<br>+—————+———-+————–+——————+<br>| louis-bin.001 | 79 | | mysql |<br>+—————+———-+————–+——————+<br>4.解开主数据库的锁<br>mysql&gt; unlock tables;<br>5.更新从数据库中主数据库的信息<br>mysql&gt; CHANGE MASTER TO<br>-> MASTER_HOST=’master_host_name’, //主服务器的IP地址<br>-> MASTER_USER=’replication_user_name’, //同步数据库的用户<br>-> MASTER_PASSWORD=’replication_password’, //同步数据库的密码<br>-> MASTER_LOG_FILE=’recorded_log_file_name’, //主服务器二进制日志的文件名(前面要求记住的参数)<br>-> MASTER_LOG_POS=recorded_log_position; //日志文件的开始位置(前面要求记住的参数)<br>6.启动从数据库的slave<br>mysql&gt; slave start;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/the-strace-command-details/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/the-strace-command-details/" itemprop="url">strace命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:29:05+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>strace 命令是一种强大的工具，它能够显示所有由用户空间程序发出的系统调用。<br>　　strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。<br>　　下面记录几个常用 option .<br>　　1 -f -F选项告诉strace同时跟踪fork和vfork出来的进程<br>　　2 -o xxx.txt 输出到某个文件。<br>　　3 -e execve 只记录 execve 这类系统调用<br>　　—————————————————<br>　　进程无法启动，软件运行速度突然变慢，程序的”SegmentFault”等等都是让每个Unix系统用户头痛的问题，<br>　　本文通过三个实际案例演示如何使用truss、strace和ltrace这三个常用的调试工具来快速诊断软件的”疑难杂症”。<br>　　<br>　　<br>　　truss和strace用来跟踪一个进程的系统调用或信号产生的情况，而 ltrace用来跟踪进程调用库函数的情况。truss是早期为System V R4开发的调试程序，包括Aix、FreeBSD在内的大部分Unix系统都自带了这个工具；<br>　　而strace最初是为SunOS系统编写的，ltrace最早出现在GNU/DebianLinux中。<br>　　这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通过Ports安装它们。<br>　　<br>　　你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：<br>　　<br>　　-f ：除了跟踪当前进程外，还跟踪其子进程。<br>　　-o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。<br>　　-p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。<br>　　<br>　　 使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：<br>　　truss -o ls.truss ls -al： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。<br>　　strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。<br>　　ltrace -p 234： 跟踪一个pid为234的已经在运行的进程。<br>　　<br>　　 三个调试工具的输出结果格式也很相似，以strace为例：<br>　　<br>　　brk(0) = 0×8062aa8<br>　　brk(0×8063000) = 0×8063000<br>　　mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0×92f) = 0×40016000<br>　　<br>　　每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 truss、strace和ltrace的工作原理大同小异，都是使用ptrace系统调用跟踪调试运行中的进程，详细原理不在本文讨论范围内，有兴趣可以参考它们的源代码。<br>　　举两个实例演示如何利用这三个调试工具诊断软件的”疑难杂症”：<br>　　<br>　　案例一：运行clint出现Segment Fault错误<br>　　<br>　　操作系统：FreeBSD-5.2.1-release<br>　　clint是一个C++静态源代码分析工具，通过Ports安装好之后，运行：<br>　　<br>　　# clint foo.cpp<br>　　Segmentation fault (core dumped)<br>　　 在Unix系统中遇见”Segmentation Fault”就像在MS Windows中弹出”非法操作”对话框一样令人讨厌。OK，我们用truss给clint”把把脉”：<br>　　<br>　　# truss -f -o clint.truss clint<br>　　Segmentation fault (core dumped)<br>　　# tail clint.truss<br>　　 739: read(0×6,0×806f000,0×1000) = 4096 (0×1000)<br>　　 739: fstat(6,0xbfbfe4d0) = 0 (0×0)<br>　　 739: fcntl(0×6,0×3,0×0) = 4 (0×4)<br>　　 739: fcntl(0×6,0×4,0×0) = 0 (0×0)<br>　　 739: close(6) = 0 (0×0)<br>　　 739: stat(“/root/.clint/plugins”,0xbfbfe680) ERR#2 ‘No such file or directory’<br>　　SIGNAL 11<br>　　SIGNAL 11<br>　　Process stopped because of: 16<br>　　process exit, rval = 139<br>　　我们用truss跟踪clint的系统调用执行情况，并把结果输出到文件clint.truss，然后用tail查看最后几行。<br>　 　注意看clint执行的最后一条系统调用（倒数第五行）：stat(“/root/.clint/plugins”,0xbfbfe680) ERR#2 ‘No such file or directory’，问题就出在这里：clint找不到目录”/root/.clint/plugins”，从而引发了段错误。怎样解决？很简单： mkdir -p /root/.clint/plugins，不过这次运行clint还是会”Segmentation Fault”9。继续用truss跟踪，发现clint还需要这个目录”/root/.clint/plugins/python”，建好这个目录后 clint终于能够正常运行了。<br>　　<br>　　案例二：vim启动速度明显变慢<br>　　<br>　　操作系统：FreeBSD-5.2.1-release<br>　 　vim版本为6.2.154，从命令行运行vim后，要等待近半分钟才能进入编辑界面，而且没有任何错误输出。仔细检查了.vimrc和所有的vim脚 本都没有错误配置，在网上也找不到类似问题的解决办法，难不成要hacking source code？没有必要，用truss就能找到问题所在：<br>　　<br>　　# truss -f -D -o vim.truss vim<br>　　<br>　　这里-D参数的作用是：在每行输出前加上相对时间戳，即每执行一条系统调用所耗费的时间。我们只要关注哪些系统调用耗费的时间比较长就可以了，用less仔细查看输出文件vim.truss，很快就找到了疑点：<br>　　<br>　　735: 0.000021511 socket(0×2,0×1,0×0) = 4 (0×4)<br>　　735: 0.000014248 setsockopt(0×4,0×6,0×1,0xbfbfe3c8,0×4) = 0 (0×0)<br>　　735: 0.000013688 setsockopt(0×4,0xffff,0×8,0xbfbfe2ec,0×4) = 0 (0×0)<br>　　735: 0.000203657 connect(0×4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 ‘Connection refused’<br>　　735: 0.000017042 close(4) = 0 (0×0)<br>　　735: 1.009366553 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0×0)<br>　　735: 0.000019556 socket(0×2,0×1,0×0) = 4 (0×4)<br>　　735: 0.000013409 setsockopt(0×4,0×6,0×1,0xbfbfe3c8,0×4) = 0 (0×0)<br>　　735: 0.000013130 setsockopt(0×4,0xffff,0×8,0xbfbfe2ec,0×4) = 0 (0×0)<br>　　735: 0.000272102 connect(0×4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 ‘Connection refused’<br>　　735: 0.000015924 close(4) = 0 (0×0)<br>　　735: 1.009338338 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0×0)<br>　　<br>　 　vim试图连接10.57.18.27这台主机的6000端口（第四行的connect（）），连接失败后，睡眠一秒钟继续重试（第6行的 nanosleep（））。以上片断循环出现了十几次，每次都要耗费一秒多钟的时间，这就是vim明显变慢的原因。可是，你肯定会纳闷：”vim怎么会无 缘无故连接其它计算机的6000端口呢？”。问得好，那么请你回想一下6000是什么服务的端口？没错，就是X Server。看来vim是要把输出定向到一个远程X Server，那么Shell中肯定定义了DISPLAY变量，查看.cshrc，果然有这么一行：setenv DISPLAY ${REMOTEHOST}:0，把它注释掉，再重新登录，问题就解决了。<br>　　<br>　　<br>　　案例三：用调试工具掌握软件的工作原理<br>　　<br>　　操作系统：Red Hat Linux 9.0<br>　 　用调试工具实时跟踪软件的运行情况不仅是诊断软件”疑难杂症”的有效的手段，也可帮助我们理清软件的”脉络”，即快速掌握软件的运行流程和工作原理，不 失为一种学习源代码的辅助方法。下面这个案例展现了如何使用strace通过跟踪别的软件来”触发灵感”，从而解决软件开发中的难题的。<br>　　大家都知道，在进程内打开一个文件，都有唯一一个文件描述符（fd：file descriptor）与这个文件对应。而本人在开发一个软件过程中遇到这样一个问题：<br>　 　已知一个fd，如何获取这个fd所对应文件的完整路径？不管是Linux、FreeBSD或是其它Unix系统都没有提供这样的API，怎么办呢？我们 换个角度思考：Unix下有没有什么软件可以获取进程打开了哪些文件？如果你经验足够丰富，很容易想到lsof，使用它既可以知道进程打开了哪些文件，也 可以了解一个文件被哪个进程打开。好，我们用一个小程序来试验一下lsof，看它是如何获取进程打开了哪些文件。lsof： 显示进程打开的文件。<br>　　<br>　　/* testlsof.c <em>/<br>　　#include #include #include #include #include<br>　　int main(void)<br>　　{<br>　　 open(“/tmp/foo”, O_CREAT|O_RDONLY); /</em> 打开文件/tmp/foo <em>/<br>　　 sleep(1200); /</em> 睡眠1200秒，以便进行后续操作 */<br>　　 return 0;<br>　　}<br>　　<br>　　将testlsof放入后台运行，其pid为3125。命令lsof -p 3125查看进程3125打开了哪些文件，我们用strace跟踪lsof的运行，输出结果保存在lsof.strace中：<br>　　<br>　　# gcc testlsof.c -o testlsof<br>　　# ./testlsof &amp;<br>　　[1] 3125<br>　　# strace -o lsof.strace lsof -p 3125<br>　　<br>　　我们以”/tmp/foo”为关键字搜索输出文件lsof.strace，结果只有一条：<br>　　<br>　　<br>　　# grep ‘/tmp/foo’ lsof.strace<br>　　readlink(“/proc/3125/fd/3”, “/tmp/foo”, 4096) = 8<br>　　<br>　 　原来lsof巧妙的利用了/proc/nnnn/fd/目录（nnnn为pid）：Linux内核会为每一个进程在/proc/建立一个以其pid为名 的目录用来保存进程的相关信息，而其子目录fd保存的是该进程打开的所有文件的fd。目标离我们很近了。好，我们到/proc/3125/fd/看个究 竟：<br>　　<br>　　# cd /proc/3125/fd/<br>　　# ls -l<br>　　total 0<br>　　lrwx—— 1 root root 64 Nov 5 09:50 0 -&gt; /dev/pts/0<br>　　lrwx—— 1 root root 64 Nov 5 09:50 1 -&gt; /dev/pts/0<br>　　lrwx—— 1 root root 64 Nov 5 09:50 2 -&gt; /dev/pts/0<br>　　lr-x—— 1 root root 64 Nov 5 09:50 3 -&gt; /tmp/foo<br>　　# readlink /proc/3125/fd/3<br>　　/tmp/foo<br>　　<br>　　答案已经很明显了：/proc/nnnn/fd/目录下的每一个fd文件都是符号链接，而此链接就指向被该进程打开的一个文件。我们只要用readlink()系统调用就可以获取某个fd对应的文件了，代码如下：<br>　　<br>　　<br>　　#include #include #include #include #include #include<br>　　int get_pathname_from_fd(int fd, char pathname[], int n)<br>　　{<br>　　 char buf[1024];<br>　　 pid_t pid;<br>　　 bzero(buf, 1024);<br>　　 pid = getpid();<br>　　 snprintf(buf, 1024, “/proc/%i/fd/%i”, pid, fd);<br>　　 return readlink(buf, pathname, n);<br>　　}<br>　　int main(void)<br>　　{<br>　　 int fd;<br>　　 char pathname[4096];<br>　　 bzero(pathname, 4096);<br>　　 fd = open(“/tmp/foo”, O_CREAT|O_RDONLY);<br>　　 get_pathname_from_fd(fd, pathname, 4096);<br>　　 printf(“fd=%d; pathname=%sn”, fd, pathname);<br>　　 return 0;<br>　　}<br>　　<br>　 　出于安全方面的考虑，在FreeBSD 5 之后系统默认已经不再自动装载proc文件系统，因此，要想使用truss或strace跟踪程序，你必须手工装载proc文件系统：mount -t procfs proc /proc；或者在/etc/fstab中加上一行：<br>　　<br>　　proc /proc procfs rw 0 0</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/the-lsof-command-details/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/the-lsof-command-details/" itemprop="url">lsof 命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:28:33+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lsof全名list opened files，也就是列举系统中已经被打开的文件。我们都知道，linux环境中，任何事物都是文件，设备是文件，目录是文件，甚至sockets也是文 件。所以，用好lsof命令，对日常的linux管理非常有帮助。以下的说明，大部分内容来自lsof的manual文档。我所做的只是在中文翻译的基础 上，进行简单的分类说明，并列举最常用的参数。</p>
<p>一、输出说明<br>   lsof是linux最常用的命令之一，通常的输出格式为：</p>
<p>引用<br>COMMAND     PID   USER   FD      TYPE     DEVICE     SIZE       NODE NAME</p>
<p>常见包括如下几个字段：更多的可见manual。<br>1、COMMAND<br>默认以9个字符长度显示的命令名称。可使用+c参数指定显示的宽度，若+c后跟的参数为零，则显示命令的全名<br>2、PID：进程的ID号<br>3、PPID<br>父进程的IP号，默认不显示，当使用-R参数可打开。<br>4、PGID<br>进程组的ID编号，默认也不会显示，当使用-g参数时可打开。<br>5、USER<br>命令的执行UID或系统中登陆的用户名称。默认显示为用户名，当使用-l参数时，可显示UID。<br>6、FD<br>是文件的File Descriptor number，或者如下的内容：<br>（这里很难翻译对应的意思，保留英文）</p>
<p>引用<br>cwd  current working directory;<br>Lnn  library references (AIX);<br>jld  jail directory (FreeBSD);<br>ltx  shared library text (code and data);<br>Mxx  hex memory-mapped type number xx.<br>m86  DOS Merge mapped file;<br>mem  memory-mapped file;<br>mmap memory-mapped device;<br>pd   parent directory;<br>rtd  root directory;<br>tr   kernel trace file (OpenBSD);<br>txt  program text (code and data);<br>v86  VP/ix mapped file;</p>
<p>文件的File Descriptor number显示模式有：</p>
<p>引用<br>r for read access;<br>w for write access;<br>u for read and write access;<br>N for a Solaris NFS lock of unknown type;<br>r for read lock on part of the file;<br>R for a read lock on the entire file;<br>w for a write lock on part of the file;<br>W for a write lock on the entire file;<br>u for a read and write lock of any length;<br>U for a lock of unknown type;<br>x for an SCO OpenServer Xenix lock on part  of the file;<br>X  for an SCO OpenServer Xenix lock on the entire file;<br>space if there is no lock.</p>
<p>7、TYPE</p>
<p>引用<br>IPv4 IPv4的包；<br>IPv6 使用IPv6格式的包，即使地址是IPv4的，也会显示为IPv6，而映射到IPv6的地址；<br>DIR 目录<br>LINK 链接文件</p>
<p>详情请看manual中更多的注释。<br>8、DEVICE<br>使用character special、block special表示的设备号<br>9、SIZE<br>文件的大小，如果不能用大小表示的，会留空。使用-s参数控制。<br>10、NODE<br>本地文件的node码，或者协议，如TCP等<br>11、NAME<br>挂载点和文件的全路径（链接会被解析为实际路径），或者连接双方的地址和端口、状态等</p>
<p>二、参数<br>1、不带额外参数运行</p>
<p>lsof path/filename</p>
<p>显示已打开该目录或文件的所有进程信息</p>
<p>lsof `which httpd`</p>
<p>显示指定命令的信息<br>2、参见参数<br>-c w 显示以w开头命令的已打开文件的信息</p>
<p>lsof -c sshd</p>
<p>-p PID 显示指定PID已打开文件的信息</p>
<p>lsof -p 4401</p>
<p>+d dir 依照文件夹dir来搜寻，但不会打开子目录</p>
<p>lsof +d /root</p>
<p>+D dir 打开dir文件夹以及其子目录搜寻</p>
<p>lsof +D /root/</p>
<p>-d s 以FD列的信息进行匹配，可使用3-10，表示范围，3,10表示某些值</p>
<p>lsof -d 3-10</p>
<p>-u 显示某用户的已经打开的文件（或该用户执行程序已经打开的文件）</p>
<p>lsof -u root<br>lsof -u 0</p>
<p>◎可配合正规表达式使用<br>表示不包括root用户的信息：</p>
<p>lsof -u ^root</p>
<p>-i 监听指定的协议、端口、主机等的网络信息，格式为：</p>
<p>引用<br>[46][proto][@host|addr][:svc_list|port_list]</p>
<p>例如：</p>
<p>lsof -i <a href="mailto:tcp@192.168.228.244" target="_blank" rel="noopener">tcp@192.168.228.244</a>为防备电子邮件地址收集器，这个 E-mail 地址被隐藏，你的浏览器必须支持 Javascript 才可看到这个邮件地址<br>lsof -i:22</p>
<p>还可以使用一些参数控制显示结果：</p>
<p>引用<br>-l 禁止将userID转换为登陆名称，即显示UID<br>-n 禁止将IP地址转换为hostname主机文件<br>-P 不显示端口名称</p>
<p>-g s 从PGID列进行匹配</p>
<p>lsof -g 3-10</p>
<p>3、其他参数<br>+f 所有路径参数都必须是文件系统，否则不能执行<br>-f 所有路径参数都将作为普通的文件，例如：”-f – /“中的/，只会匹配单个/路径，而不会是根目录中的所有文件<br>+f和-f后都应加上“–”表终结符：</p>
<p>lsof -f – /</p>
<p>+L/-L 打开或关闭文件的连结数计算，当+L没有指定时，所有的连结数都会显示（默认）；若+L后指定数字，则只要连结数小于该数字的信息会显示；连结数会显示在NLINK列。<br>例如：+L1将显示没有unlinked的文件信息；+aL1，则显示指定文件系统所有unlinked的文件信息<br>-L 默认参数，其后不能跟数字，将不显示连结数信息</p>
<p>lsof +L1</p>
<p>-t 仅打印进程，方便shell脚本调用</p>
<p>lsof -t -c sshd</p>
<p>-F 指定输出那个列，可通过lsof -F?查看<br>-r 不断执行lsof命令，默认每15秒间隔执行一次<br>+r 也是不断执行lsof命令，但直到没有接受到文件信息，则停止</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/using-truss-strace-or-ltrace-diagnostic-software-amp-quot-complications-amp-quot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/using-truss-strace-or-ltrace-diagnostic-software-amp-quot-complications-amp-quot/" itemprop="url">使用truss、strace或ltrace诊断软件的&quot;疑难杂症&quot;</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:27:58+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程无法启动，软件运行速度突然变慢，程序的”Segment Fault”等等都是让每个Unix系统用户头痛的问题，本文通过三个实际案例演示如何使用truss、strace和ltrace这三个常用的调试工具来快速诊断软件的”疑难杂症”。  </p>
<pre><code>truss 和strace用来跟踪一个进程的系统调用或信号产生的情况，而 ltrace用来跟踪进程调用库函数的情况。truss是早期为System V R4开发的调试程序，包括Aix、FreeBSD在内的大部分Unix系统都自带了这个工具；而strace最初是为SunOS系统编写的，ltrace 最早出现在GNU/Debian Linux中。这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通 过Ports安装它们。  

你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：  
</code></pre><p>de&gt;-f ：除了跟踪当前进程外，还跟踪其子进程。<br>-o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。<br>-p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。de&gt;</p>
<pre><code>使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：  
</code></pre><p>de&gt;truss -o ls.truss ls -al： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。<br>strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。<br>ltrace -p 234： 跟踪一个pid为234的已经在运行的进程。de&gt;</p>
<pre><code>三个调试工具的输出结果格式也很相似，以strace为例：  
</code></pre><p>de&gt;brk(0)                                  = 0x8062aa8<br>brk(0x8063000)                          = 0x8063000<br>mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0x92f) = 0x40016000de&gt;</p>
<pre><code>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 truss、strace和ltrace的工作原理大同小异，都是使用ptrace系统调用跟踪调试运行中的进程，详细原理不在本文讨论范围内，有兴趣可以参考它们的源代码。

举两个实例演示如何利用这三个调试工具诊断软件的&quot;疑难杂症&quot;：  
</code></pre><p><strong>案例一：运行clint出现Segment Fault错误</strong>  </p>
<pre><code>操作系统：FreeBSD-5.2.1-release  

clint是一个C++静态源代码分析工具，通过Ports安装好之后，运行：  
</code></pre><p>de&gt;# clint foo.cpp<br>Segmentation fault (core dumped)de&gt;</p>
<pre><code>在Unix系统中遇见&quot;Segmentation Fault&quot;就像在MS Windows中弹出&quot;非法操作&quot;对话框一样令人讨厌。OK，我们用truss给clint&quot;把把脉&quot;：  
</code></pre><p>de&gt;# truss -f -o clint.truss clint<br>Segmentation fault (core dumped)<br># tail clint.truss<br>  739: read(0x6,0x806f000,0x1000)               = 4096 (0x1000)<br>  739: fstat(6,0xbfbfe4d0)                       = 0 (0x0)<br>  739: fcntl(0x6,0x3,0x0)                        = 4 (0x4)<br>  739: fcntl(0x6,0x4,0x0)                        = 0 (0x0)<br>  739: close(6)                                    = 0 (0x0)<br>  739: stat(“/root/.clint/plugins”,0xbfbfe680)   ERR#2 ‘No such file or directory’<br>SIGNAL 11<br>SIGNAL 11<br>Process stopped because of:  16<br>process exit, rval = 139de&gt;</p>
<pre><code>我 们用truss跟踪clint的系 统调用执行情况，并把结果输出到文件clint.truss，然后用tail查看最后几行。注意看clint执行的最后一条系统调用（倒数第五 行）：stat(&quot;/root/.clint/plugins&quot;,0xbfbfe680) ERR#2 &apos;No such file or directory&apos;，问题就出在这里：clint找不到目录&quot;/root/.clint/plugins&quot;，从而引发了段错误。怎样解决？很简单： mkdir -p /root/.clint/plugins，不过这次运行clint还是会&quot;Segmentation Fault&quot;9。继续用truss跟踪，发现clint还需要这个目录&quot;/root/.clint/plugins/python&quot;，建好这个目录后 clint终于能够正常运行了。  
</code></pre><p><strong>案例二：vim启动速度明显变慢</strong>  </p>
<pre><code>操作系统：FreeBSD-5.2.1-release  

vim 版本为6.2.154，从命令行运行vim后，要等待近半分钟才能进入编辑界面，而且没有任何错误输出。仔细检查了. vimrc和所有的vim脚本都没有错误配置，在网上也找不到类似问题的解决办法，难不成要hacking source code？没有必要，用truss就能找到问题所在：  
</code></pre><p>de&gt;# truss -f -D -o vim.truss vimde&gt;</p>
<pre><code>这里-D参数的作用是：在每行输出前加上相对时间戳，即每执行一条系统调用所耗费的时间。我们只要关注哪些系统调用耗费的时间比较长就可以了，用less仔细查看输出文件vim.truss，很快就找到了疑点：  
</code></pre><p>de&gt;735: 0.000021511 socket(0x2,0x1,0x0)       = 4 (0x4)<br>735: 0.000014248 setsockopt(0x4,0x6,0x1,0xbfbfe3c8,0x4) = 0 (0x0)<br>735: 0.000013688 setsockopt(0x4,0xffff,0x8,0xbfbfe2ec,0x4) = 0 (0x0)<br>735: 0.000203657 connect(0x4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 ‘Connection refused’<br>735: 0.000017042 close(4)          = 0 (0x0)<br>735: 1.009366553 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0x0)<br>735: 0.000019556 socket(0x2,0x1,0x0)       = 4 (0x4)<br>735: 0.000013409 setsockopt(0x4,0x6,0x1,0xbfbfe3c8,0x4) = 0 (0x0)<br>735: 0.000013130 setsockopt(0x4,0xffff,0x8,0xbfbfe2ec,0x4) = 0 (0x0)<br>735: 0.000272102 connect(0x4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 ‘Connection refused’<br>735: 0.000015924 close(4)          = 0 (0x0)<br>735: 1.009338338 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0x0)de&gt;</p>
<p> vim 试图连接10.57.18.27这台主机的6000端口（第四行的 connect（）），连接失败后，睡眠一秒钟继续重试（第6行的nanosleep（））。以上片断循环出现了十几次，每次都要耗费一秒多钟的时间，这 就是vim明显变慢的原因。可是，你肯定会纳闷：”vim怎么会无缘无故连接其它计算机的6000端口呢？”。问得好，那么请你回想一下6000是什么服 务的端口？没错，就是X Server。看来vim是要把输出定向到一个远程X Server，那么Shell中肯定定义了DISPLAY变量，查看.cshrc，果然有这么一行：setenv DISPLAY ${REMOTEHOST}:0，把它注释掉，再重新登录，问题就解决了。  </p>
<p><strong>案例三：用调试工具掌握软件的工作原理</strong>  </p>
<pre><code>操作系统：Red Hat Linux 9.0  

用 调试工具实时跟踪软件的运行情况不仅是诊断软件&quot;疑难杂症&quot;的有效的手段，也可帮助我们理清软件的&quot;脉络&quot;，即快速掌握软件的运行流程和工作原理，不失为 一种学习源代码的辅助方法。下面这个案例展现了如何使用strace通过跟踪别的软件来&quot;触发灵感&quot;，从而解决软件开发中的难题的。  

大 家都知道，在进程内打开一个文件，都有唯一一个文件描述符（fd：file descriptor）与这个文件对应。而本人在开发一个软件过程中遇到这样一个问题：已知一个fd ，如何获取这个fd所对应文件的完整路径？不管是Linux、FreeBSD或是其它Unix系统都没有提供这样的API，怎么办呢？我们换个角度思考： Unix下有没有什么软件可以获取进程打开了哪些文件？如果你经验足够丰富，很容易想到lsof，使用它既可以知道进程打开了哪些文件，也可以了解一个文 件被哪个进程打开。好，我们用一个小程序来试验一下lsof，看它是如何获取进程打开了哪些文件。  
</code></pre><p>de&gt;/<em> testlsof.c </em>/  </p>
<p>#include &lt;stdio.h&gt;  </p>
<p>#include &lt;unistd.h&gt;  </p>
<p>#include &lt;sys/types.h&gt;  </p>
<p>#include &lt;sys/stat.h&gt;  </p>
<p>#include &lt;fcntl.h&gt;  </p>
<p>int main(void)<br>{<br>        open(“/tmp/foo”, O_CREAT|O_RDONLY);    /<em> 打开文件/tmp/foo </em>/<br>        sleep(1200);                                /<em> 睡眠1200秒，以便进行后续操作 </em>/<br>        return 0;<br>}de&gt;</p>
<pre><code>将testlsof放入后台运行，其pid为3125。命令lsof -p 3125查看进程3125打开了哪些文件，我们用strace跟踪lsof的运行，输出结果保存在lsof.strace中：  
</code></pre><p>de&gt;# gcc testlsof.c -o testlsof<br># ./testlsof &amp;<br>[1] 3125<br># strace -o lsof.strace lsof -p 3125de&gt;</p>
<pre><code>我们以&quot;/tmp/foo&quot;为关键字搜索输出文件lsof.strace，结果只有一条：  
</code></pre><p>de&gt;# grep ‘/tmp/foo’ lsof.strace<br>readlink(“/proc/3125/fd/3”, “/tmp/foo”, 4096) = 8de&gt;</p>
<p>原 来lsof巧妙的利用了/proc/nnnn/fd/目录（nnnn为 pid）：Linux内核会为每一个进程在/proc/建立一个以其pid为名的目录用来保存进程的相关信息，而其子目录fd保存的是该进程打开的所有文 件的fd。目标离我们很近了。好，我们到/proc/3125/fd/看个究竟：  </p>
<p>de&gt;# cd /proc/3125/fd/<br># ls -l<br>total 0<br>lrwx——    1 root     root           64 Nov  5 09:50 0 -&gt; /dev/pts/0<br>lrwx——    1 root     root           64 Nov  5 09:50 1 -&gt; /dev/pts/0<br>lrwx——    1 root     root           64 Nov  5 09:50 2 -&gt; /dev/pts/0<br>lr-x——    1 root     root           64 Nov  5 09:50 3 -&gt; /tmp/foo<br># readlink /proc/3125/fd/3<br>/tmp/foode&gt;</p>
<pre><code>答案已经很明显了：/proc/nnnn/fd/目录下的每一个fd文件都是符号链接，而此链接就指向被该进程打开的一个文件。我们只要用readlink()系统调用就可以获取某个fd对应的文件了，代码如下：  
</code></pre><p>de&gt;#include &lt;stdio.h&gt;  </p>
<p>#include &lt;string.h&gt;  </p>
<p>#include &lt;sys/types.h&gt;  </p>
<p>#include &lt;unistd.h&gt;  </p>
<p>#include &lt;fcntl.h&gt;  </p>
<p>#include &lt;sys/stat.h&gt;<br>int get_pathname_from_fd(int fd, char pathname[], int n)<br>{<br>        char buf[1024];<br>        pid_t  pid;<br>        bzero(buf, 1024);<br>        pid = getpid();<br>        snprintf(buf, 1024, “/proc/%i/fd/%i”, pid, fd);<br>        return readlink(buf, pathname, n);<br>}<br>int main(void)<br>{<br>        int fd;<br>        char pathname[4096];<br>        bzero(pathname, 4096);<br>        fd = open(“/tmp/foo”, O_CREAT|O_RDONLY);<br>        get_pathname_from_fd(fd, pathname, 4096);<br>        printf(“fd=%d; pathname=%s<br>“, fd, pathname);<br>        return 0;<br>}de&gt;</p>
<pre><code>出 于安全方面的考虑，在FreeBSD 5 之后系统默认已经不再自动装载proc文件系统，因此，要想使用truss或strace跟踪程序，你必须手工装载proc文件系统：mount -t procfs proc /proc；或者在/etc/fstab中加上一行：  
</code></pre><p>de&gt;proc                   /proc           procfs  rw              0       0de&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/smartmontools-hard-disk-detection-tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/smartmontools-hard-disk-detection-tool/" itemprop="url">Smartmontools---硬盘检测工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:27:20+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1-什么是Smartmontools？"><a href="#1-1-什么是Smartmontools？" class="headerlink" title="1.1 什么是Smartmontools？"></a>1.1 什么是Smartmontools？</h1><p>Smartmontools 是一种硬盘检测工具，通过控制和管理硬盘的SMART（Self Monitoring Analysis and Reporting Technology，自动检测分析及报告技术）技术来实现的，SMART技术可以对硬盘的磁头单元、盘片电机驱动系统、硬盘内部电路以及盘片表面介质材 料等进行监测，当SMART监测并分析出硬盘可能出现问题时会及时向用户报警以避免计算机数据受损失。SMART技术必须在主板支持的前提下才能发生作 用，而且 SMART技术也不能保证能预报所有可能发生的硬盘故障。SMART(SFF-8035i) 是硬盘生产商们建立的一个工业标准，这个标准就是在硬盘上保存一个跟执行情况，可靠程度，读找错误率等属性的表格。所有属性都有一个1byte(大小范围 1-253)的标准化值，还包含另一个1byte的关键阶段值，如果属性表格内某个数据接近小于或达到关键阶段值，表明硬盘工作不正常了。</p>
<h1 id="2-1-Smartmontools的使用"><a href="#2-1-Smartmontools的使用" class="headerlink" title="2.1 Smartmontools的使用"></a>2.1 Smartmontools的使用</h1><p>1、启动监控进程</p>
<p># /etc/init.d/smartd start<br>启动 smartd：                                              [  确定  ]</p>
<p>2、检查硬盘是否支持SMART 1993年以后出厂的硬盘基本上都支持SMART技术，使用如下命令可以来查看：</p>
<p># smartctl -i /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF INFORMATION SECTION ===<br>Device Model:     ST3160212A<br>Serial Number:    5LS2EDKN<br>Firmware Version: 3.AAE<br>User Capacity:    160,041,885,696 bytes<br>Device is:        Not in smartctl database [for details use: -P showall]<br>ATA Version is:   7<br>ATA Standard is:  Exact ATA specification draft version not indicated<br>Local Time is:    Mon Sep 17 02:13:37 2007 CST<br>SMART support is: Available - device has SMART capability.<br>SMART support is: Enabled</p>
<p>在上面的信息可以看到，该硬盘是支持SMART技术，且当前是开启的。如果SMART support is: Disabled表示SMART未启用，执行如下命令，启动SMART：</p>
<p>smartctl –smart=on –offlineauto=on –saveauto=on /dev/hdb</p>
<p>3、检查硬盘健康状态</p>
<p># smartctl -H /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART overall-health self-assessment test result: PASSED</p>
<p>请 注意result后边的结果：PASSED，这表示硬盘健康状态良好，如果这里显示Failure，那么最好立刻给服务器更换硬盘。SMART只 能报告磁盘已经不再健康，但是报警后还能继续运行多久是不确定的，通常，SMART报警参数是有预留的，磁盘报警后，不会当场坏掉，一般能坚持一段时间， 有的硬盘SMART报警后还继续跑了好几年，有的硬盘SMART报错后几天就坏了，千万不要存在侥幸心理。执行如下命令可以看到详细的参数：</p>
<p># smartctl -A /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Attributes Data Structure revision number: 10<br>Vendor Specific SMART Attributes with Thresholds:<br>ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE<br>  1 Raw_Read_Error_Rate     0x000f   114   100   006    Pre-fail  Always       -       81812244<br>  3 Spin_Up_Time            0x0003   100   099   000    Pre-fail  Always       -       0<br>  4 Start_Stop_Count        0x0032   100   100   020    Old_age   Always       -       257<br>  5 Reallocated_Sector_Ct   0x0033   100   100   036    Pre-fail  Always       -       0<br>  7 Seek_Error_Rate         0x000f   078   060   030    Pre-fail  Always       -       64781708<br>  9 Power_On_Hours          0x0032   096   096   000    Old_age   Always       -       4365<br> 10 Spin_Retry_Count        0x0013   100   100   097    Pre-fail  Always       -       0<br> 12 Power_Cycle_Count       0x0032   100   100   020    Old_age   Always       -       276<br>187 Unknown_Attribute       0x0032   100   100   000    Old_age   Always       -       0<br>189 Unknown_Attribute       0x003a   100   100   000    Old_age   Always       -       0<br>190 Unknown_Attribute       0x0022   058   053   045    Old_age   Always       -       773324842<br>194 Temperature_Celsius     0x0022   042   047   000    Old_age   Always       -       42 (Lifetime Min/Max 0/21)<br>195 Hardware_ECC_Recovered  0x001a   052   048   000    Old_age   Always       -       1562815<br>197 Current_Pending_Sector  0x0012   100   100   000    Old_age   Always       -       0<br>198 Offline_Uncorrectable   0x0010   100   100   000    Old_age   Offline      -       0<br>199 UDMA_CRC_Error_Count    0x003e   200   200   000    Old_age   Always       -       0<br>200 Multi_Zone_Error_Rate   0x0000   100   253   000    Old_age   Offline      -       0<br>202 TA_Increase_Count       0x0032   100   253   000    Old_age   Always       -       0</p>
<p>FLAG是标记，标准数值(VALUE)应当小于或等於关键值(THRESH)。WHEN_FAILED 代表错误信息，上面显示的WHEN_FAILED纵行是空行，说明硬盘没有故障。如果WHEN_FAILED显示数字，表明硬盘磁道可能有比较大的坏道。</p>
<p>4、对硬盘进行检测 手工对硬盘进行测试的方法有以下四种：</p>
<p>smartctl -t short <device>    后台检测硬盘，消耗时间短<br>smartctl -t long <device>      后台检测硬盘，消耗时间长<br>smartctl -C -t short <device> 前台检测硬盘，消耗时间短<br>smartctl -C -t long <device>  前台检测硬盘，消耗时间长</device></device></device></device></p>
<p>例如，在后台对硬盘进行详细的检查，命令如下：</p>
<p># smartctl -t long /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF OFFLINE IMMEDIATE AND SELF-TEST SECTION ===<br>Sending command: “Execute SMART Extended self-test routine immediately in off-line mode”.<br>Drive command “Execute SMART Extended self-test routine immediately in off-line mode” successful.<br>Testing has begun.<br>Please wait 54 minutes for test to complete.<br>Test will complete after Mon Sep 17 03:53:32 2007  </p>
<p>Use smartctl -X to abort test.</p>
<p>上面的信息显示54分钟后将完成检查，同时可以使用 smartctl -X 终止检查。终止硬盘检查命令的使用方法是：</p>
<p># smartctl -X /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF OFFLINE IMMEDIATE AND SELF-TEST SECTION ===<br>Sending command: “Abort SMART off-line mode self-test routine”.<br>Self-testing aborted!</p>
<p>5、查看硬盘日志 使用“smartctl -l logtype <device>”可以查看硬盘的日志，日志又分为多种类型，如selftest、error等等。例如查看硬盘检测的日志，如下：</device></p>
<p># smartctl -l selftest /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Self-test log structure revision number 1<br>Num  Test_Description    Status                  Remaining  LifeTime(hours)  LBA_of_first_error<br># 1  Extended offline    Aborted by host               90%      4365         -<br># 2  Extended offline    Completed without error       00%      4247         -<br># 3  Short offline       Aborted by ho<br>st               30%      4246         -<br># 4  Short offline       Aborted by host               10%      4246         -<br># 5  Extended offline    Completed without error       00%      4229         -</p>
<p>查看硬盘错误日志：</p>
<p># smartctl -l error /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Error Log Version: 1<br>No Errors Logged</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5"
                alt="haitian" />
            
              <p class="site-author-name" itemprop="name">haitian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">277</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haitian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
