<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="haitian的博客">
<meta property="og:url" content="http://yoursite.com/page/24/index.html">
<meta property="og:site_name" content="haitian的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="haitian的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/24/"/>





  <title>haitian的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">haitian的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">为了更好的生活而奋斗!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/smartmontools-hard-disk-detection-tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/smartmontools-hard-disk-detection-tool/" itemprop="url">Smartmontools---硬盘检测工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:27:20+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1-什么是Smartmontools？"><a href="#1-1-什么是Smartmontools？" class="headerlink" title="1.1 什么是Smartmontools？"></a>1.1 什么是Smartmontools？</h1><p>Smartmontools 是一种硬盘检测工具，通过控制和管理硬盘的SMART（Self Monitoring Analysis and Reporting Technology，自动检测分析及报告技术）技术来实现的，SMART技术可以对硬盘的磁头单元、盘片电机驱动系统、硬盘内部电路以及盘片表面介质材 料等进行监测，当SMART监测并分析出硬盘可能出现问题时会及时向用户报警以避免计算机数据受损失。SMART技术必须在主板支持的前提下才能发生作 用，而且 SMART技术也不能保证能预报所有可能发生的硬盘故障。SMART(SFF-8035i) 是硬盘生产商们建立的一个工业标准，这个标准就是在硬盘上保存一个跟执行情况，可靠程度，读找错误率等属性的表格。所有属性都有一个1byte(大小范围 1-253)的标准化值，还包含另一个1byte的关键阶段值，如果属性表格内某个数据接近小于或达到关键阶段值，表明硬盘工作不正常了。</p>
<h1 id="2-1-Smartmontools的使用"><a href="#2-1-Smartmontools的使用" class="headerlink" title="2.1 Smartmontools的使用"></a>2.1 Smartmontools的使用</h1><p>1、启动监控进程</p>
<p># /etc/init.d/smartd start<br>启动 smartd：                                              [  确定  ]</p>
<p>2、检查硬盘是否支持SMART 1993年以后出厂的硬盘基本上都支持SMART技术，使用如下命令可以来查看：</p>
<p># smartctl -i /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF INFORMATION SECTION ===<br>Device Model:     ST3160212A<br>Serial Number:    5LS2EDKN<br>Firmware Version: 3.AAE<br>User Capacity:    160,041,885,696 bytes<br>Device is:        Not in smartctl database [for details use: -P showall]<br>ATA Version is:   7<br>ATA Standard is:  Exact ATA specification draft version not indicated<br>Local Time is:    Mon Sep 17 02:13:37 2007 CST<br>SMART support is: Available - device has SMART capability.<br>SMART support is: Enabled</p>
<p>在上面的信息可以看到，该硬盘是支持SMART技术，且当前是开启的。如果SMART support is: Disabled表示SMART未启用，执行如下命令，启动SMART：</p>
<p>smartctl –smart=on –offlineauto=on –saveauto=on /dev/hdb</p>
<p>3、检查硬盘健康状态</p>
<p># smartctl -H /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART overall-health self-assessment test result: PASSED</p>
<p>请 注意result后边的结果：PASSED，这表示硬盘健康状态良好，如果这里显示Failure，那么最好立刻给服务器更换硬盘。SMART只 能报告磁盘已经不再健康，但是报警后还能继续运行多久是不确定的，通常，SMART报警参数是有预留的，磁盘报警后，不会当场坏掉，一般能坚持一段时间， 有的硬盘SMART报警后还继续跑了好几年，有的硬盘SMART报错后几天就坏了，千万不要存在侥幸心理。执行如下命令可以看到详细的参数：</p>
<p># smartctl -A /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Attributes Data Structure revision number: 10<br>Vendor Specific SMART Attributes with Thresholds:<br>ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE<br>  1 Raw_Read_Error_Rate     0x000f   114   100   006    Pre-fail  Always       -       81812244<br>  3 Spin_Up_Time            0x0003   100   099   000    Pre-fail  Always       -       0<br>  4 Start_Stop_Count        0x0032   100   100   020    Old_age   Always       -       257<br>  5 Reallocated_Sector_Ct   0x0033   100   100   036    Pre-fail  Always       -       0<br>  7 Seek_Error_Rate         0x000f   078   060   030    Pre-fail  Always       -       64781708<br>  9 Power_On_Hours          0x0032   096   096   000    Old_age   Always       -       4365<br> 10 Spin_Retry_Count        0x0013   100   100   097    Pre-fail  Always       -       0<br> 12 Power_Cycle_Count       0x0032   100   100   020    Old_age   Always       -       276<br>187 Unknown_Attribute       0x0032   100   100   000    Old_age   Always       -       0<br>189 Unknown_Attribute       0x003a   100   100   000    Old_age   Always       -       0<br>190 Unknown_Attribute       0x0022   058   053   045    Old_age   Always       -       773324842<br>194 Temperature_Celsius     0x0022   042   047   000    Old_age   Always       -       42 (Lifetime Min/Max 0/21)<br>195 Hardware_ECC_Recovered  0x001a   052   048   000    Old_age   Always       -       1562815<br>197 Current_Pending_Sector  0x0012   100   100   000    Old_age   Always       -       0<br>198 Offline_Uncorrectable   0x0010   100   100   000    Old_age   Offline      -       0<br>199 UDMA_CRC_Error_Count    0x003e   200   200   000    Old_age   Always       -       0<br>200 Multi_Zone_Error_Rate   0x0000   100   253   000    Old_age   Offline      -       0<br>202 TA_Increase_Count       0x0032   100   253   000    Old_age   Always       -       0</p>
<p>FLAG是标记，标准数值(VALUE)应当小于或等於关键值(THRESH)。WHEN_FAILED 代表错误信息，上面显示的WHEN_FAILED纵行是空行，说明硬盘没有故障。如果WHEN_FAILED显示数字，表明硬盘磁道可能有比较大的坏道。</p>
<p>4、对硬盘进行检测 手工对硬盘进行测试的方法有以下四种：</p>
<p>smartctl -t short <device>    后台检测硬盘，消耗时间短<br>smartctl -t long <device>      后台检测硬盘，消耗时间长<br>smartctl -C -t short <device> 前台检测硬盘，消耗时间短<br>smartctl -C -t long <device>  前台检测硬盘，消耗时间长</device></device></device></device></p>
<p>例如，在后台对硬盘进行详细的检查，命令如下：</p>
<p># smartctl -t long /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF OFFLINE IMMEDIATE AND SELF-TEST SECTION ===<br>Sending command: “Execute SMART Extended self-test routine immediately in off-line mode”.<br>Drive command “Execute SMART Extended self-test routine immediately in off-line mode” successful.<br>Testing has begun.<br>Please wait 54 minutes for test to complete.<br>Test will complete after Mon Sep 17 03:53:32 2007  </p>
<p>Use smartctl -X to abort test.</p>
<p>上面的信息显示54分钟后将完成检查，同时可以使用 smartctl -X 终止检查。终止硬盘检查命令的使用方法是：</p>
<p># smartctl -X /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF OFFLINE IMMEDIATE AND SELF-TEST SECTION ===<br>Sending command: “Abort SMART off-line mode self-test routine”.<br>Self-testing aborted!</p>
<p>5、查看硬盘日志 使用“smartctl -l logtype <device>”可以查看硬盘的日志，日志又分为多种类型，如selftest、error等等。例如查看硬盘检测的日志，如下：</device></p>
<p># smartctl -l selftest /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Self-test log structure revision number 1<br>Num  Test_Description    Status                  Remaining  LifeTime(hours)  LBA_of_first_error<br># 1  Extended offline    Aborted by host               90%      4365         -<br># 2  Extended offline    Completed without error       00%      4247         -<br># 3  Short offline       Aborted by ho<br>st               30%      4246         -<br># 4  Short offline       Aborted by host               10%      4246         -<br># 5  Extended offline    Completed without error       00%      4229         -</p>
<p>查看硬盘错误日志：</p>
<p># smartctl -l error /dev/hdb<br>smartctl version 5.33 [i686-turbo-linux-gnu] Copyright (C) 2002-4 Bruce Allen<br>Home page is <a href="http://smartmontools.sourceforge.net/" target="_blank" rel="noopener">http://smartmontools.sourceforge.net/</a>  </p>
<p>=== START OF READ SMART DATA SECTION ===<br>SMART Error Log Version: 1<br>No Errors Logged</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/use-smartmontools-to-monitor-the-health-of-your-disks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/use-smartmontools-to-monitor-the-health-of-your-disks/" itemprop="url">使用smartmontools监控磁盘的健康状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:26:46+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/watch-monitor-command-run-results/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/watch-monitor-command-run-results/" itemprop="url">watch -- 监测命令的运行结果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:26:08+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>watch 是一个非常实用的命令，基本所有的 Linux 发行版都带有这个小工具，如同名字一样，watch 可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</p>
<p>举 例来说，Linux 系统有一个基础命令 w，可以显示当前的 uptime、负载还有登录的用户，非常方便，但是如果我想监测这些数据，看看有没有新用户登入，看看某段的时间的负载是不是太大之类的，就得手动一遍遍 的运行这个命令，然后查看结果，虽然命令只有一个字母，但是还是很郁闷……</p>
<p>watch 就是干这个用的，直接在 watch 后面接你想运行的命令，watch 就会帮你重复运行，并把每次的结果都更新在屏幕上～</p>
<p>要想监测 w 命令的运行结果，只要 watch w 就可以了：</p>
<p><img src="http://blog.atop.fun/wp-content/uploads/netease/other_site/www_linuxeden_1533080.png" alt="" title="watch -- 监测命令的运行结果 - suchalin - 为了更好的生活而奋斗！"></p>
<p>默认 watch 会以 2s 的间隔重复运行命令，你也可以用 -n 参数指定时间间隔～</p>
<p>还有一个实用的参数是 -d，这样 watch 会帮你高亮显示变化的区域，这样更加一目了然了～ <img src="http://blog.atop.fun/wp-content/uploads/netease/other_site/www_linuxeden_1533081.gif" alt="" title="watch -- 监测命令的运行结果 - suchalin - 为了更好的生活而奋斗！"></p>
<p><img src="http://blog.atop.fun/wp-content/uploads/netease/other_site/www_linuxeden_1533082.png" alt="" title="watch -- 监测命令的运行结果 - suchalin - 为了更好的生活而奋斗！"></p>
<p>Ctrl+c 就可以退出～</p>
<p>你可以拿他来监测你想要的一切命令的结果变化，比如 tail 一个 log 文件，ls 监测某个文件的大小变化，看你的想象力了～ <img src="http://blog.atop.fun/wp-content/uploads/netease/other_site/www_linuxeden_1533083.gif" alt="" title="watch -- 监测命令的运行结果 - suchalin - 为了更好的生活而奋斗！"></p>
<p>如果你的发行版中不幸没有这个命令，可以到<a href="http://procps.sourceforge.net/" target="_blank" rel="noopener">这里</a>下载安装，watch 属于 procps 这个软件包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/linux-ps-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/linux-ps-command/" itemprop="url">linux的ps命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:25:30+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>linux的ps命令和top都是用来监视系统进程和资源使用情况的有用命令, ps命令更为常用, 所以掌握ps命令是很有必要的</p>
<p>ps命令如果有任何疑问,请在终端下输入 :# man ps</p>
<p>名称：ps<br>使用权限：所有使用者<br>使用方式：ps [options] [–help]<br>说明：显示瞬间行程 (process) 的动态<br>参数：<br>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程</p>
<p>au(x) 输出格式 :</p>
<p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p>
<p>范例：</p>
<p>ps<br>PID TTY TIME CMD<br>2791 ttyp0 00:00:00 tcsh<br>3092 ttyp0 00:00:00 ps<br>% ps -A<br>PID TTY TIME CMD<br>1 ? 00:00:03 init<br>2 ? 00:00:00 kflushd<br>3 ? 00:00:00 kpiod<br>4 ? 00:00:00 kswapd<br>5 ? 00:00:00 mdrecoveryd<br>…….<br>% ps -aux<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>root 1 0.0 0.7 1096 472 ? S Sep10 0:03 init [3]<br>root 2 0.0 0.0 0 0 ? SW Sep10 0:00 [kflushd]<br>root 3 0.0 0.0 0 0 ? SW Sep10 0:00 [kpiod]<br>root 4 0.0 0.0 0 0 ? SW Sep10 0:00 [kswapd]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/linux-debug-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/linux-debug-command/" itemprop="url">linux下调试命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:25:01+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>调试程序时有用的命令：<br>gdb Linux下的调试器<br>pstack 查看进程的调用栈，如果是多线程的话，可以查看每个线程的调用栈<br>pmap 查看内存的映射情况<br>strace 跟踪进程的系统调用<br>ltrace 跟踪程序的系统调用<br>ldd 查看依赖库<br>lsof 查看进程打开的所有文件</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/the-principle-and-use-of-ldd-commands/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/the-principle-and-use-of-ldd-commands/" itemprop="url">LDD命令的原理与使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:24:24+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>作用：用来查看程式运行所需的共享库**</strong>,<strong>**常用来解决程式因缺少某个库文件而不能运行的一些问题。</strong><br>ldd命令原理</p>
<p>1、首先ldd不是个可执行程式，而只是个shell脚本<br>2、ldd能够显示可执行模块的dependency，<strong>其原理是通过设置一系列的环境变量</strong>，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_OBJECTS环境变量不为空时，所有可执行程式在运行时，他<strong>都会只显示模块的**</strong>dependency<strong>**，而程式并不真正执行。</strong>要不你能在shell终端测试一下，如下：(1) export LD_TRACE_LOADED_OBJECTS=1<br>(2) 再执行所有的程式，如ls等，看看程式的运行结果<br>3、<strong>ldd**</strong>显示可执行模块的<strong><strong>dependency</strong></strong>的工作原理，其实质是通过<strong><strong>ld-linux.so</strong></strong>（<strong><strong>elf</strong></strong>动态库的装载器）来实现的。<strong>我们知道，ld-linux.so模块会先于executable模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。<br>4、</strong>实际上能直接执行<strong><strong>ld-linux.so</strong></strong>模块，如：<strong><strong>/lib/ld-linux.so.2 –list program</strong></strong>（这相当于<strong><strong>ldd program</strong></strong>）<strong><br>ldd命令使用方法(摘自ldd –help)<br>名称ldd - 打印共享库的依赖关系<br>大纲    ldd [选项]…　文件…<br>描述</strong>ldd<strong> </strong>输出在命令行上指定的每个程式或共享库需要的共享库。**选项<br> –version　　　　　　　打印ldd的版本号<br> -v –verbose　　　　　　　打印所有信息，例如包括符号的版本信息<br> -d –data-relocs　　　　　　　执行符号重部署，并报告缺少的目标对象（只对ELF格式适用）<br> -r –function-relocs　　　　　　　对目标对象和函数执行重新部署，并报告缺少的目标对象和函数（只对ELF格式适用）<br> –help 用法信息<br>注意:<br> ldd的标准版本和glibc2一起提供。Libc5和老版本以前提供，在一些系统中还存在。在libc5版本中长选项不支持。另一方面，glibc2版本不支持-V选项，只提供等价的–version选项。<br>  如果命令行中给定的库名字包含’/’，这个程式的libc5版本将使用他作为库名字；否则他将在标准位置搜索库。运行一个当前目录下的共享库，加前缀”./“。<br>错误:<br> ldd不能工作在a.out格式的共享库上。<br> ldd不能工作在一些非常老的a.out程式上，这些程式在支持ldd的编译器发行前已创建。如果你在这种类型的程式上使用ldd，程式将尝试argc = 0的运行方式，其结果不可预知。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/linux-pmap-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/linux-pmap-command/" itemprop="url">linux之pmap命令！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:22:29+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>观察到系统中的指定进程的地址空间分布情况显示一个目标文件或者链接库文件中的目标文件的各个段的大小。该文件从/proc//maps中获得数据。<br>命令格式：<br>pmap  </p>
<p>范例：<br>[root@localhost security]# pmap -d 4993<br>4993: -bash<br>Address Kbytes Mode Offset Device Mapping<br>08047000 596 r-x– 0000000000000000 003:00006 bash bash的代码段<br>080dc000 28 rwx– 0000000000094000 003:00006 bash bash的数据段<br>080e3000 280 rwx– 00000000080e3000 000:00000 [ anon ] bash的堆<br>4d575000 84 r-x– 0000000000000000 003:00006 ld-2.3.4.so 共享库的代码段<br>4d58a000 4 r-x– 0000000000015000 003:00006 ld-2.3.4.so 共享库的数据段<br>4d58b000 4 rwx– 0000000000016000 003:00006 ld-2.3.4.so 共享库的堆<br>4d58e000 1164 r-x– 0000000000000000 003:00006 libc-2.3.4.so<br>4d6b1000 4 r-x– 0000000000123000 003:00006 libc-2.3.4.so<br>4d6b2000 12 rwx– 0000000000124000 003:00006 libc-2.3.4.so<br>4d6b5000 8 rwx– 000000004d6b5000 000:00000 [ anon ] 匿名物理内存，<br>4d6de000 8 r-x– 0000000000000000 003:00006 libdl-2.3.4.so<br>4d6e0000 8 rwx– 0000000000001000 003:00006 libdl-2.3.4.so<br>4d807000 12 r-x– 0000000000000000 003:00006 libtermcap.so.2.0.8<br>4d80a000 4 rwx– 0000000000002000 003:00006 libtermcap.so.2.0.8<br>b7bc2000 176 r-x– 0000000000000000 003:00006 GB18030.so<br>b7bee000 8 rwx– 000000000002b000 003:00006 GB18030.so<br>b7bf0000 24 r-xs- 0000000000000000 003:00006 gconv-modules.cache<br>b7bf6000 1060 r-x– 0000000002197000 003:00006 locale-archive<br>b7cff000 2048 r-x– 0000000000000000 003:00006 locale-archive<br>b7eff000 36 r-x– 0000000000000000 003:00006 libnss_files-2.3.4.so<br>b7f08000 8 rwx– 0000000000008000 003:00006 libnss_files-2.3.4.so<br>b7f0a000 8 rwx– 00000000b7f0a000 000:00000 [ anon ]<br>b7f20000 8 rwx– 00000000b7f20000 000:00000 [ anon ]<br>bff0d000 84 rw— 00000000bff0d000 000:00000 [ stack ]<br>ffffe000 4 —– 0000000000000000 000:00000 [ anon ]<br>mapped: 5680K writeable/private: 460K shared: 24K  </p>
<p>每列的含义如下：<br>参数 解释<br>Address:00378000-0038d000 进程所占的地址空间<br>Kbytes 该虚拟段的大小<br>RSS 设备号（主设备：次设备）<br>Anon 设备的节点号，0表示没有节点与内存相对应<br>Locked 是否允许swapped<br>Mode 权限：r=read, w=write, x=execute, s=shared, p=private(copy on write)<br>Mapping: bash 对应的映像文件名  </p>
<p>[root@localhost security]# pmap -x 4993<br>4993: -bash<br>Address Kbytes RSS Anon Locked Mode Mapping<br>08047000 596 - - - r-x– bash<br>080dc000 28 - - - rwx– bash<br>080e3000 280 - - - rwx– [ anon ]<br>4d575000 84 - - - r-x– ld-2.3.4.so<br>4d58a000 4 - - - r-x– ld-2.3.4.so<br>4d58b000 4 - - - rwx– ld-2.3.4.so<br>4d58e000 1164 - - - r-x– libc-2.3.4.so<br>4d6b1000 4 - - - r-x– libc-2.3.4.so<br>4d6b2000 12 - - - rwx– libc-2.3.4.so<br>4d6b5000 8 - - - rwx– [ anon ]<br>4d6de000 8 - - - r-x– libdl-2.3.4.so<br>4d6e0000 8 - - - rwx– libdl-2.3.4.so<br>4d807000 12 - - - r-x– libtermcap.so.2.0.8<br>4d80a000 4 - - - rwx– libtermcap.so.2.0.8<br>b7bc2000 176 - - - r-x– GB18030.so<br>b7bee000 8 - - - rwx– GB18030.so<br>b7bf0000 24 - - - r-xs- gconv-modules.cache<br>b7bf6000 1060 - - - r-x– locale-archive<br>b7cff000 2048 - - - r-x– locale-archive<br>b7eff000 36 - - - r-x– libnss_files-2.3.4.so<br>b7f08000 8 - - - rwx– libnss_files-2.3.4.so<br>b7f0a000 8 - - - rwx– [ anon ]<br>b7f20000 8 - - - rwx– [ anon ]<br>bff0d000 84 - - - rw— [ stack ]<br>ffffe000 4 - - - —– [ anon ]<br>-------- ------- ------- ------- -------<br>total kB 5680 - - -</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/a-solution-to-track-unix-applications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/a-solution-to-track-unix-applications/" itemprop="url">跟踪 UNIX 应用程序的解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:21:34+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用 truss 和 strace</p>
<p>在 Solaris 和 AIX 上可以使用 truss 工具，它能够跟踪应用程序中的系统调用和信号。可以在 Linux? 上使用的 strace 工具提供相似的功能。在不同的系统上，还有提供相似信息的其他工具，包括 ktrace (FreeBSD) 和 trace。</p>
<p>truss/strace 概述</p>
<p>truss 和 strace 工具提供相似的信息，但是命令行选项稍有差异。使用这两种工具的标准方法都是把工具名放在要执行的命令前面。</p>
<p>例如，清单 3 给出 truss 对于本教程前面提到的 ageindays 程序的输出。</p>
<p><strong>清单 3. truss 的输出</strong>  </p>
<p>$ truss ./ageindays 24/1/1980 26/3/2009<br>execve(“ageindays”, 0x08047BBC, 0x08047BCC)  argc = 3<br>mmap(0x00000000, 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, -1, 0)<br>   = 0xFEFB0000<br>resolvepath(“/usr/lib/ld.so.1”, “/lib/ld.so.1”, 1023) = 12<br>getcwd(“/root”, 1013)                           = 0<br>resolvepath(“/root/ageindays”, “/root/ageindays”, 1023) = 15<br>xstat(2, “/root/ageindays”, 0x08047880)         = 0<br>open(“/var/ld/ld.config”, O_RDONLY)             = 3<br>fxstat(2, 3, 0x08047760)                        = 0<br>mmap(0x00000000, 144, PROT_READ, MAP_SHARED, 3, 0) = 0xFEFA0000<br>close(3)                                        = 0<br>sysconfig(_CONFIG_PAGESIZE)                     = 4096<br>xstat(2, “/usr/lib/libc.so.1”, 0x08046FA0)      = 0<br>resolvepath(“/usr/lib/libc.so.1”, “/lib/libc.so.1”, 1023) = 14<br>open(“/usr/lib/libc.so.1”, O_RDONLY)            = 3<br>mmap(0x00010000, 32768, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_ALIGN, 3, 0)<br>    = 0xFEF90000<br>mmap(0x00010000, 1413120, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANON|MAP_ALIGN, -1, 0)<br>    = 0xFEE30000<br>mmap(0xFEE30000, 1302809, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_TEXT, 3, 0)<br>    = 0xFEE30000<br>mmap(0xFEF7F000, 30862, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|<br>    MAP_INITDATA, 3, 1306624) = 0xFEF7F000<br>mmap(0xFEF87000, 4776, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANON,<br>   -1, 0) = 0xFEF87000<br>munmap(0xFEF6F000, 65536)                       = 0<br>memcntl(0xFEE30000, 187632, MC_ADVISE, MADV_WILLNEED, 0, 0) = 0<br>close(3)                                        = 0<br>mmap(0x00010000, 24576, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON|MAP_ALIGN,<br>   -1, 0)<br>    = 0xFEE20000<br>munmap(0xFEF90000, 32768)                       = 0<br>getcontext(0x080475D0)<br>getrlimit(RLIMIT_STACK, 0x080475C8)             = 0<br>getpid()                                        = 15691 [15690]<br>lwp_private(0, 1, 0xFEE22A00)                   = 0x000001C3<br>setustack(0xFEE22A60)<br>sysi86(SI86FPSTART, 0xFEF879BC, 0x0000133F, 0x00001F80) = 0x00000001<br>ioctl(1, TCGETA, 0x08046C20)                    = 0<br>fstat64(1, 0x08046B80)                          = 0<br>You have been alive 10654 days<br>write(1, “ Y o u   h a v e   b e e”.., 31)      = 31<br>You were born on 24/1/1980 which is a Thursday<br>write(1, “ Y o u   w e r e   b o r”.., 47)      = 47<br>_exit(134511508)  </p>
<p>清单 4 给出 Linux 上 strace 的输出。</p>
<p><strong>清单 4. strace 的输出</strong>  </p>
<p>$ strace ./ageindays 24/1/1980 26/3/2009<br>execve(“./ageindays”, [“./ageindays”, “24/1/1980”, “26/3/2009”],<br>[/* 50 vars */]) = 0<br>brk(0)                                  = 0x602000<br>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br>    = 0x7f47db185000<br>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br>    = 0x7f47db184000<br>access(“/etc/ld.so.preload”, R_OK)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/lib/tls/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/lib/tls/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/lib/tls/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/lib/tls”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/lib/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/lib/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/lib/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/lib”, {st_mode=S_IFDIR|0755, st_size=53248, …}) = 0<br>open(“/usr/local/lib/tls/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/lib/tls/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/lib/tls/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/lib/tls”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/lib/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/lib/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/lib/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/lib”, {st_mode=S_IFDIR|0755, st_size=4096, …}) = 0<br>open(“/usr/local/qt/lib/tls/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/qt/lib/tls/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/qt/lib/tls/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/qt/lib/tls”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/qt/lib/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/qt/lib/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/local/qt/lib/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/local/qt/lib”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/X11R6/lib/tls/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/X11R6/lib/tls/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/X11R6/lib/tls/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/X11R6/lib/tls”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/X11R6/lib/x86_64/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/X11R6/lib/x86_64”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/usr/X11R6/lib/libc.so.6”, O_RDONLY)<br>    = -1 ENOENT (No such file or directory)<br>stat(“/usr/X11R6/lib”, 0x7fffe31858f0)<br>    = -1 ENOENT (No such file or directory)<br>open(“/etc/ld.so.cache”, O_RDONLY)      = 3<br>fstat(3, {st_mode=S_IFREG|0644, st_size=85050, …}) = 0<br>mmap(NULL, 85050, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f47db16f000<br>close(3)                                = 0<br>open(“/lib/libc.so.6”, O_RDONLY)        = 3<br>read(3, “177ELF211?????????3?&gt;1???3003451?????@”…,<br>    832) = 832<br>fstat(3, {st_mode=S_IFREG|0755, st_size=1330352, …}) = 0<br>mmap(NULL, 3437208, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0)<br>    = 0x7f47dac24000<br>mprotect(0x7f47dad63000, 2093056, PROT_NONE) = 0<br>mmap(0x7f47daf62000, 20480, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE,<br>    3, 0x13e000) = 0x7f47daf62000<br>mmap(0x7f47daf67000, 17048, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,<br>   -1, 0) = 0x7f47daf67000<br>clo<br>se(3)                                = 0<br>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br>    = 0x7f47db16e000<br>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br>    = 0x7f47db16d000<br>arch_prctl(ARCH_SET_FS, 0x7f47db16d6f0) = 0<br>mprotect(0x7f47daf62000, 16384, PROT_READ) = 0<br>mprotect(0x600000, 4096, PROT_READ)     = 0<br>mprotect(0x7f47db186000, 4096, PROT_READ) = 0<br>munmap(0x7f47db16f000, 85050)           = 0<br>fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), …}) = 0<br>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br>    = 0x7f47db183000<br>write(1, “You have been alive 10654 days<br>“…, 31You have been alive 10654 days<br>) = 31<br>write(1, “You were born on 24/1/1980 which “…, 47You were born on 24/1/1980<br>   which is a Thursday<br>) = 47<br>exit_group(0)    </p>
<p>在这两个输出中，每个输出行对应于应用程序执行的一个函数调用，其中显示函数的参数和函数调用的返回值。与调试示例不同，列出的每个函数调用都是系统或系统库中的函数，因此表示调用的函数的更低层接口。例如，在应用程序中可能使用 C 或 C++ 中的 de&lt;fpopen()de&lt; 函数打开文件，但是这个函数实际上是更低层的 de&lt;open()de&lt; 函数的包装器。</p>
<p>了解应用程序正在执行的操作并不需要了解每个函数的情况。输出中的许多行与操作系统为装载和执行程序所做的初始化相关。这两个跟踪输出的基本结构是相同的：</p>
<ul>
<li>调用 de&lt;execve()de&lt; 函数以启动一个新程序。</li>
<li>装载程序所需的库。在 Solaris 输出中，首先使用 de&lt;resolvepath()de&lt; 寻找库，然后使用 de&lt;open()de&lt; 打开库。对于 Linux，使用 de&lt;stat()de&lt; 检查库是否存在，然后使用 de&lt;open()de&lt; 打开它。</li>
<li>为进程保留和分配一些内存。其中一部分内存是为应用程序保留的堆栈空间，一部分用来保存程序，其他内存保存程序使用的变量。</li>
<li>最后，执行程序，调用 de&lt;write()de&lt; 函数输出年龄和生日信息。</li>
</ul>
<p>如果执行跟踪并希望了解每个步骤的具体情况，可以使用 man 命令访问每个函数的手册页。</p>
<p>识别应用程序启动问题</p>
<p>在启动应用程序时的一个典型问题是，程序无法正确地初始化，但是在终止时给出一个不完整或导致误解的消息。对应用程序运行跟踪常常可以揭示这个问题的根源。例如，清单 5 显示一个测试应用程序运行失败了。</p>
<p><strong>清单 5. 应用程序失败</strong>  </p>
<p>$ ./errnoacc<br>ERROR: Application failed to initialize  </p>
<p>错误消息并没有提供关于应用程序为什么会启动失败的具体信息。在这里，问题是故意引入的，但是您使用的任何命令或应用程序都可能出现相同的问题，而错误消息没什么帮助，有时候甚至没有错误消息。</p>
<p>对应用程序运行跟踪可能会提供一些线索（见清单 6）。</p>
<p><strong>清单 6. 运行跟踪</strong>  </p>
<p>$ truss ./errnoacc<br>execve(“errnoacc”, 0x08047B20, 0x08047B28)  argc = 1<br>mmap(0x00000000, 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, -1, 0)<br>    = 0xFEFB0000<br>resolvepath(“/usr/lib/ld.so.1”, “/lib/ld.so.1”, 1023) = 12<br>getcwd(“/export/home/mc”, 1014)                 = 0<br>resolvepath(“/export/home/mc/errnoacc”, “/export/home/mc/errnoacc”, 1023) = 24<br>xstat(2, “/export/home/mc/errnoacc”, 0x080477E4) = 0<br>open(“/var/ld/ld.config”, O_RDONLY)             = 3<br>fxstat(2, 3, 0x080476C4)                        = 0<br>mmap(0x00000000, 144, PROT_READ, MAP_SHARED, 3, 0) = 0xFEFA0000<br>close(3)                                        = 0<br>sysconfig(_CONFIG_PAGESIZE)                     = 4096<br>xstat(2, “/usr/lib/libc.so.1”, 0x08046F04)      = 0<br>resolvepath(“/usr/lib/libc.so.1”, “/lib/libc.so.1”, 1023) = 14<br>open(“/usr/lib/libc.so.1”, O_RDONLY)            = 3<br>mmap(0x00010000, 32768, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_ALIGN, 3, 0) = 0xFEF90000<br>mmap(0x00010000, 1413120, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE|MAP_ANON|MAP_ALIGN,<br>    -1, 0) = 0xFEE30000<br>mmap(0xFEE30000, 1302809, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_TEXT, 3, 0)<br>    = 0xFEE30000<br>mmap(0xFEF7F000, 30862, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|<br>    MAP_INITDATA, 3, 1306624) = 0xFEF7F000<br>mmap(0xFEF87000, 4776, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANON,<br>    -1, 0) = 0xFEF87000<br>munmap(0xFEF6F000, 65536)                       = 0<br>memcntl(0xFEE30000, 187632, MC_ADVISE, MADV_WILLNEED, 0, 0) = 0<br>close(3)                                        = 0<br>mmap(0x00010000, 24576, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON|MAP_ALIGN,<br>    -1, 0) = 0xFEE20000<br>munmap(0xFEF90000, 32768)                       = 0<br>getcontext(0x08047534)<br>getrlimit(RLIMIT_STACK, 0x0804752C)             = 0<br>getpid()                                        = 15727 [15726]<br>lwp_private(0, 1, 0xFEE22A00)                   = 0x000001C3<br>setustack(0xFEE22A60)<br>sysi86(SI86FPSTART, 0xFEF879BC, 0x0000133F, 0x00001F80) = 0x00000001<br>open(“/etc/shadow”, O_RDONLY)                   Err#13 EACCES [file_dac_read]<br>ioctl(1, TCGETA, 0x08046BB0)                    = 0<br>fstat64(1, 0x08046B10)                          = 0<br>ERROR: Application failed to initialize<br>write(1, “ E R R O R :   A p p l i”.., 40)      = 40<br>_exit(0)  </p>
<p>问题出现在这一行上：de&lt;open(“/etc/shadow”, O_RDONLY) Err#13 EACCES [file_dac_read]de&lt;。</p>
<p>在这里，应用程序试图打开一个文件，但是因为有文件权限保护这个文件，运行应用程序的用户没有访问权。因为无法打开这个文件，应用程序终止并在进程中写错误消息。</p>
<p>跟踪正在运行的应用程序</p>
<p>希望跟踪应用程序常常是因为应用程序已经启动，而您希望查明应用程序为什么不工作了。与初始化示例一样，应用程序提供的错误消息或其他信息常常没有准确地指出问题。</p>
<p>试图锁定或访问另一个进程正在使用的资源会使应用程序看起来冻结了，没有响应。</p>
<p>strace 和 truss 都能够 “连接” 到正在运行的进程。连接到进程的跟踪与从命令行运行进程的跟踪相似，也产生程序正在执行的系统函数的列表。实际的跟踪从跟踪启动时执行的函数开始；对于在执行期间 “挂起” 的程序，跟踪应该会显示程序正在等待的函数。</p>
<p>要想跟踪正在运行的程序，需要指定要跟踪的进程的进程 ID (PID)。例如，在清单 6 中，跟踪的程序已经停止，但是没有报告错误。这里使用 ps 工具列出正在运行的进程（见清单 7）。</p>
<p><strong>清单 7. 使用 ps 工具列出正在运行的进程</strong>  </p>
<p>$ ps -ef|grep errlock<br>      mc 15779 15747   0 18:26:59 pts/2       0:00 ./errlock<br>      mc 15742   680   0 18:26:36 pts/3       0:00 ./errlock<br>      mc 15817 15784   0 18:28:44 pts/4       0:00 grep errlock<br>      mc 15734   680   0 18:25:00 pts/3       0:01 /usr/bin/emacs-nox errlock.c<br>$ truss -p 15779<br>fcntl(3, F_SETLKW, 0x08047AC4)  (sleeping…)  </p>
<p>在输出中可以看到，已经调用了 de&lt;fcntl()de&lt; 函数，它要在一个文件上设置锁。在这里，这个函数会一直等待到成功地设置锁，然后才继续运行。不幸的是，另一个进程已经锁住了这个文件，所以第二个应用程序必须等待第一个应用程序使用完文件并释放锁。</p>
<p>对 于这种情况，truss 有点儿局限性：它无法指出要锁住哪个文件，也无法指出当前锁住了哪个文件，从而阻碍了第二个程序的执行。这是因为跟踪过程是在已经调用了打开文件的函数之 后启动的。truss 和 strace 只跟踪在它们执行期间调用的函数；它们无法查明已经调用的函数。</p>
<p>获取堆栈跟踪</p>
<p>可以看出，truss 对于监视整个程序很有用，但是对于监视已经启动的程序可能有点儿局限性。如果使用基于 SVR4 的 UNIX，比如 Solaris 或 AIX，那么 pstack 命令可能有帮助。</p>
<p>pstack 命令实际上属于一组进程检查命令，这些命令输出正在运行的进程的相关信息。其他工具包括 pfiles（输出进程使用的文件的列表）和 psig（显示信号和信号处理函数的列表）。</p>
<p>在使用这些命令时，需要指定进程的 PID。pstack 命令输出一个正在运行的进程的调用堆栈，显示在进程到达当前函数之前调用的函数。例如，对正在等待被锁住的文件的进程使用 pstack，会产生清单 8 中的输出。</p>
<p><strong>清单 8. 对正在等待被锁住的文件的进程使用 pstack</strong>  </p>
<p>$ pstack 15828<br>15828:  ./errlock<br> feef0877 fcntl    (3, 7, 8047ac4)<br> feedcd49 fcntl    (3, 7, 8047ac4, 8050e74) + 91<br> 08050f10 main     (1, 8047b24, 8047b2c) + d8<br> 08050cdc _start   (1, 8047c08, 0, 8047c12, 8047c7d, 8047c8e) + 80  </p>
<p>在这里，它没有提供我们需要的信息。现在试试 pfiles（见清单 9）。</p>
<p><strong>清单 9. 使用 pfiles</strong>  </p>
<p>$ pfiles 15856<br>15856:  ./errlock<br>  Current rlimit: 256 file descriptors<br>   0: S_IFCHR mode:0620 dev:292,0 ino:989038936 uid:101 gid:7 rdev:24,3<br>      O_RDWR|O_NOCTTY|O_LARGEFILE<br>      /dev/pts/3<br>   1: S_IFCHR mode:0620 dev:292,0 ino:989038936 uid:101 gid:7 rdev:24,3<br>      O_RDWR|O_NOCTTY|O_LARGEFILE<br>      /dev/pts/3<br>   2: S_IFCHR mode:0620 dev:292,0 ino:989038936 uid:101 gid:7 rdev:24,3<br>      O_RDWR|O_NOCTTY|O_LARGEFILE<br>      /dev/pts/3<br>   3: S_IFREG mode:0666 dev:182,65545 ino:198 uid:101 gid:10 size:0<br>      O_RDWR<br>      advisory write lock set by process 15828<br>      /export/home/mc/lockdemo  </p>
<p>这些输出就比较有用了。可以看到进程已经打开的文件称为 lockdemo ，因为 truss 显示正在等待文件锁，所以可能是这个文件导致了问题。</p>
<p>truss 和 strace 都是被动的跟踪。可以查看正在执行的函数，但是无法了解关于正在发生的情况的详细信息，也无法更有针对性地指定要跟踪的东西和跟踪时要输出的信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/application-tracking-makes-quantitative-analysis-of-performance-changes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/application-tracking-makes-quantitative-analysis-of-performance-changes/" itemprop="url">应用程序跟踪对性能改变进行量化分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:18:11+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用 Apache Web 服务器作为示例，以了解如何分析公共配置的性能含义。使用应用程序跟踪来观察应用程序运行过程中进行的系统调用。通过统计调用的次数和发生的时间，您可以轻松地了解性能改变的影响。</p>
<p>您 可以对应用程序进行跟踪，以找出它们暂停或不运行的原因。并且可以使用同样的方法，了解更多关于应用程序的信息并理解某些配置的性能含义。因为 Apache 非常流行并且大多数读者对它都比较熟悉，所以本文使用 Apache 作为示例。Apache 所进行的每次系统调用都会对 Web 页面的提供带来延迟，通过跟踪不同配置下的 Web 服务器，您可以确定具体配置的影响。</p>
<p>应用程序跟踪概述</p>
<p>在应用程序的执行 过程中，当需要打开文件、发送数据包或者使用系统资源时，它会对基础操作系统进行相应的系统调用。跟踪应用程序意味着可以 在调用发生时观察到这些系统调用，这将使得您能够深入地了解该应用程序的行为。在 Solaris 和 IBM AIX? 操作系统 (AIX) 中，使用 truss 命令完成这项任务，而在 Linux? 中则使用 strace。清单 1 显示了对 pwd 命令进行跟踪的示例。</p>
<p>清单 1. 跟踪 pwd 命令</p>
<p>-bash-3.00$ truss pwd … getcwd(“/export/home/sean”, 1025) = 0 /export/home/sean write(1, “ / e x p o r t / h o m e”.., 18) = 18 _exit(0)</p>
<p>在删除开始处与加载该应用程序相关的输出内容后，您可以看到所进行的三次系统调用：</p>
<p>getcwd 返回当前工作目录。输出内容中显示了字符串“/export/home/sean”返回到缓冲区。</p>
<p>write 可以显示给定的字符串。因为在其执行之后才显示这个系统调用，所以先输出了它的执行结果。还可以注意到，write 系统调用的结果是写入字符的个数数目，在这个示例中为 17 加上一个回车。</p>
<p>_exit 使用错误代码 0 退出该程序，这个错误代码通常表示成功结束。</p>
<p>尽管这是一个很简单的示例，但它演示了通过应用程序跟踪可以观察程序内部机制的程度。有关跟踪方面更深入的信息，请参见参考资料部分。</p>
<p>Apache 配置的简要介绍</p>
<p>可以通过一个名为 httpd.conf 的文件对 Apache Web 服务器进行配置。清单 2 显示了一个简单配置中的部分内容。</p>
<p>清单 2. 示例 httpd.conf</p>
<p>DocumentRoot “/var/apache/htdocs” Options FollowSymLinks AllowOverride None Options Indexes FollowSymLinks MultiViews</p>
<p>第一行定义了在何处可以找到 HTML 文件。将所有的请求都映射到这个目录。如果请求 /project/charter.html，将使用 /var/apache/htdocs/project/charter.html 提供该页面。httpd.conf 中剩余的部分由两个 Directory 节组成。 和 之间的任何内容都将应用于指定目录及其所有的子目录。在本例中，第一节将两项设置应用于根目录，而第二节则指向 /var/apache/htdocs。</p>
<p>如果多个节应用于单个请求，那么将会对这些命令进行组合，并且最适合的目录具有高优先级。例如，将 使用 /var/apache/htdocs/project/charter.html 提供 /project/charter.html 请求的页面。/var/apache/htdocs 是 / 的子目录，所以 Options Indexes FollowSymLinks MultiViews 来自第二节，AllowOverride None 来自第一节。</p>
<p>可以对许多内容进行配置，并且每项内容都具有其性能含义。本文余下的内容重点关注于如何对这些改变的影响进行量化分析。</p>
<p>建立基准</p>
<p>在您进行任何调整之前，务必要了解系统当前的运行方式。使用 -X 参数启动 Apache，这个参数将强制 Apache 进入单进程调试模式。这样做可以确保将请求发送到正在进行跟踪的进程，并且消除常规进程间通信所带来的开销。</p>
<p>在 守护进程启动之后，通过运行 ps -ef 找到相应的进程 ID，并查找 httpd 守护进程。在找到该进程之后，使用 truss -c -p PID 附加到该进程。-c 选项表示对系统调用进行计数，而不是逐个显示它们，而 -p 则表示将跟踪器附加于一个正在运行的进程。</p>
<p>使用 Web 浏览器请求文档。在页面加载之后，回到 truss 应用程序，然后按 Ctrl-C 以结束计数。对于静态 HTML 页面，您应该看到如清单 3 所示的内容（为使这些数字变得更有趣，本示例进行了 100 次相同的请求）。</p>
<p>清单 3. 系统调用基准</p>
<p>sunbox# truss -c -p 15026 (make the Web request 100 times) ^C syscall seconds calls errors read .009 200 write .020 200 close .020 200 time .004 300 alarm .018 1100 fcntl .009 300 sigaction .007 400 munmap .007 100 llseek .001 100 pollsys .005 100 mmap64 .008 100 stat64 .007 100 open64 .006 100 accept .019 100 getsockname .002 100 setsockopt .002 100 ——– —— —- sys totals: .149 3600 0 usr time: .120 elapsed: 8.960</p>
<p>truss 返回系统调用的列表、执行调用耗费的总时间、调用的次数和任何发现的问题。在这个报表的结尾处，返回了这些系统调用耗费的总时间，以及执行应用程序所耗费 的时间。对于这些目的来说，所耗时间是没有意义的，因为它指的是从启动 truss 开始到其结束的时间，而与 Web 请求没有任何关系。</p>
<p>清 单 3 显示了最简单的情况。在来自 Web 浏览器的连接请求到达后，accept 系统调用完成该连接。Web 服务器使用 read 调用获得请求的内容，将请求的内容映射到磁盘上的文件。Web 服务器首先使用 stat64 验证该文件是否存在，使用 open64 打开该文件以便进行读取，然后使用 mmap64 将该文件的内容映射到内存中。然后使用 write 将这个文件发送回客户端，使用另一个 write 生成日志文件，并且服务器执行来自浏览器的最后一个 read。该列表中其余的调用都是系统开销，并且当配置发生改变时，不会有显著的变化。</p>
<p>解释这些数值</p>
<p>100 次请求总共耗费 0.269 秒 (0.149 + 0.120)，这样的性能相当不错，并且该服务器每秒钟应该可以提供大约 370 个页面 (100/0.269)。但是不能完全相信这些数值，因为它们仅表示进程耗费在 CPU 上的时间，而不是其真正的执行时间（也称为时钟时间）。还有更多的因素需要考虑，如磁盘和网络的速度、计算机上正运行的其他内容、该守护进程运行于调试模 式的事实。您还需要考虑系统调用跟踪本身的开销。</p>
<p>本文中使用的方法重点关注这些操作的相对计时和使用应用程序跟踪消除浪费掉的操作。如果您需要了解 Web 服务器每秒可以提供的页面数目，参考资料部分中有相应的软件链接，它可以帮助您确定该数值。</p>
<p>跟踪 AllowOverride 范围</p>
<p>Apache 允许管理员通过 .htaccess 机制将配置权委托给个别的用户。.htaccess 是一个包含附加配置指令的文件，如果在 httpd.conf 中通过 AllowOverride 配置了请求的目录，那么 Web 服务器将搜索这个文件。清单 4 显示了前面的配置了 AllowOverride Limit 的配置信息，它允许用户获取访问 Web 页面的用户名和密码。</p>
<p>清单 4. 配置了 AllowOverride 的示例 httpd.conf</p>
<p>DocumentRoot “/var/apache/htdocs” Options FollowSymLinks AllowOverride Limit Options Indexes FollowSymLinks MultiViews</p>
<p>重新启动 httpd 守护进程并再次运行这些测试，其结果如清单 5 所示。</p>
<p>清单 5. 开启了 AllowOverride Limit 的 100 次请求的结果</p>
<p>sunbox# truss -c -t write,read,open64,stat64,mmap64 -p 21136 ^C syscall seconds calls errors read .012 200 write .021 200 mmap64 .007 100 stat64 .007 100 open64 .022 500 400 ——– —— —- sys totals: .072 1100 400 usr time: .141 elapsed: 16.660</p>
<p>初看起来，系统调用耗费的时间下降了，但这是因为使用了 -t 选项将跟踪任务限制于一些有意义的系统调用。大多数系统调用并没有发生变化，但现在有 500 次 open64 调用，其中有 400 次返回了错误。执行 open64 的时间增加了（从 0.006 秒增加到 0.22 秒），同时用户空间部分的时间也增加了（从 0.12 秒增加到 0.141 秒）。</p>
<p>时间增加是因为 Apache 现在必须完成附加的工作以处理该请求，即使没有配置重写。单独的 AllowOverride Limit 配置明显地增加了开销。问题依然存在，即什么导致了这些错误？ 要回答这个问题，可以跟踪单个 Web 请求，如清单 6 所示。</p>
<p>清单 6. 确定 open64 调用失败的原因</p>
<p>sunbox# truss -t open64 -p 21136 open64(“/.htaccess”, O_RDONLY) Err#2 ENOENT open64(“/var/.htaccess”, O_RDONLY) Err#2 ENOENT open64(“/var/apache/.htaccess”, O_RDONLY) Err#2 ENOENT open64(“/var/apache/htdocs/.htaccess”, O_RDONLY) Err#2 ENOENT open64(“/var/apache/htdocs/test.html”, O_RDONLY) = 5</p>
<p>清单 6 显示了当请求进入时，Apache 对每个指向 /var/apache/htdocs 的目录进行检查并尝试打开 .htaccess 文件，但是因为 AllowOverride 配置为根目录，所以这个文件并不存在。Apache 必须在每个子目录中查找 .htaccess 文件的重写信息，并对它们进行处理。这样一来，由于额外的系统调用、更多的用户空间开销和额外的磁盘活动，从而进一步增加了延迟。对于 100 次请求来说，增加零点几秒的时间看起来并不是很明显，但是对于一台繁忙的服务器，就会增加更长的延迟。</p>
<p>既然您了解了重写的范围，那么理想的 解决方案是不允许重写，并且强制在 httpd.conf 中对所有的内容进行配置。如果失败，可以将配置的范围限制于需要它的目录。在这个研究示例中，把 AllowOverride Limit 放到第二个 Directory 节中，这将仅添加一个额外的 open64 调用，以便在 /var/apache/htdocs 中查找 .htaccess。对所有的父目录进行搜索是浪费时间，因为在这个配置中，不会使用其中的任何文件来提供页面。</p>
<p>研究主机名查找</p>
<p>当 Web 服务器接收到一个请求时，它所知道的关于客户端的信息只有其 IP 地址，如 129.42.42.212 对应于 IBM.com。然而，Web 服务器并不知道这个地址来自于 IBM.com，因此，它必须进行反向 DNS 查找。这样做需要耗费一定的时间，如果在发送请求之前需要这个名称，那么将会延迟对客户端的响应。过去，Apache 在缺省情况下会执行这些反向查找，但现在这种行为已经有了改变。</p>
<p>还有另一种情况，其中必须进行反向 DNS 搜索。当基于主机名（而不是 IP 地址）配置访问限制时，Apache 必须首先将 IP 地址反向解析为相应的主机名，然后再次将主机名解析为 IP 地址，以确保它们正确匹配。因为反向域名搜索可以由地址块所有者确定，所以要防止 IP 欺骗的发生，必须进行第二次查找。可以通过应用程序跟踪来确定 DNS 解析的影响吗？</p>
<p>要对其进行测试，可以从前面的示例中删除 AllowOverride Limit，然后添加 Allow from ibm.com 代替缺省的 Allow from all。然后，对 DNS 服务器进行更改以便向您的工作站返回 something.ibm.com，确保初始反向检查能够成功并且随后的正向查找必须通过 Internet 完成。在示例运行过程中，对保护的 Web 服务器的请求耗费了 15 秒的时间。相反，使用 IP 地址代替 ibm.com 所耗费的时间小于半秒钟。清单 7 显示了在使用 DNS 确保安全时，对一些系统调用进行统计。</p>
<p>清单 7. 通过主机名进行限制的 Web 请求的 truss 输出</p>
<p>bash-3.00# truss -c -p 26089 ^C syscall seconds calls errors read .000 5 write .000 3 open .000 2 close .001 10 time .000 3 stat .000 5 alarm .000 8 fcntl .000 7 2 sigaction .000 3 sysconfig .000 5 pollsys .001 5 door_info .000 2 stat64 .000 1 open64 .000 2 so_socket .001 5 accept .000 1 connect .002 5 recvfrom .000 2 send .001 5 getsockname .000 1 setsockopt .000 1 ——– —— —- sys totals: .011 81 2 usr time: .004</p>
<p>truss 报告了该进程所耗费的时间远远小于客户端感觉到的时间（0.015 秒与 15 秒）。这是因为大多数套接字操作都是异步地 进行的，其中套接字进行轮询以检查数据是否出现，而不是使得应用程序处于阻塞（等待）状态以等待响应。如此一来，应用程序在等待结果的时候不会消耗 CPU 时间。这就解释了 truss 报告的时间和客户端感觉到的时间之间出现差异的原因。</p>
<p>truss 并没有忘记所做的更改，0.015 秒比本文中研究的第一个简单示例要高一个数量级。从系统调用计数中可以看出，有一些以前没有出现过的调用，包括 read、write、close 和 stat。以及还有 send、connect、so_socket 和 pollsys，这些系统调用用于进行名称请求。因为名称解析可以来自于不同的来源，包括本地文件系统和名称缓存守护进程，所以必须对这几个位置进行检 查。在随后的调用中，请求时间小于 1 秒，这是因为对 DNS 信息进行了缓存。</p>
<p>最后，大部分的延迟来自于远程名称服务器和正向解析。这 个事实进一步强调了，如果您希望依赖于名称查找，那么就需要使用 DNS 缓存和快速 DNS 服务器。然而，最佳的解决方案是使用一种可选的方法来处理这个问题。一种比较简单的解决方案是指定 IP 地址块（如 Allow from 10.0.0.0/8），这种方法比 DNS 查找要快得多。因为反向和正向查找必须匹配，所以对名称进行的操作，很可能可以用于网段。另外，Apache 可以集成各种身份验证系统，所以基于用户的身份验证是另一种可选方法。</p>
<p>系统调用与库调用</p>
<p>如果熟悉套接字编程，那么您可能会寻 找 gethostbyname 和其他类似的调用，这些调用都可以用来执行主机查找功能。有一些库调用，由 /usr/lib 中的系统库 libc 和 libsocket 提供。库调用封装了一个或多个系统调用，以及额外的逻辑。您可以将它们作为程序员友好的接口来进行系统调用。例如，gethostbyname 库调用将执行许多步骤，以便根据服务器的配置查找相应的名称，如检查 /etc/hosts 或搜索网络信息系统 (NIS) 或 DNS。这些步骤包含了内核所提供的更小的构件，即系统调用。在大多数这样的这种情况下，两者之间的差别通常很小。truss 还可以跟踪库调用，但是无法提供像系统调用那样详细的信息。</p>
<p>结束语</p>
<p>监视和统计系统调用的功能不仅有助于进行故障排除，还有助 于理解应用程序配置如何对性能产生影响。与系统的其他部分之间的每个交互操作都会 调用一个或多个系统调用，并且每次调用都会增加系统开销。这并不是说系统调用非常糟糕，如果程序员不与其他的部分进行交互，那将是很乏味的。相反，在改变 应用程序时，您可以监视系统调用的使用，以便更好地了解这些改变对总体性能的影响。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/12/22/program-analysis-tool-gprof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haitian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haitian的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/12/22/program-analysis-tool-gprof/" itemprop="url">程序分析工具gprof介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-12-22T11:17:41+08:00">
                2009-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>程 序分析是以某种语言书写的程序为对象，对其内部的运作流程进行分析。程序分析的目的主要有三点：一是通过程序内部各个模块之间的调用关系，整体上把握程序 的运行流程，从而更好地理解程序，从中汲取有价值的内容。二是以系统优化为目的，通过对程序中关键函数的跟踪或者运行时信息的统计，找到系统性能的瓶颈， 从而采取进一步行动对程序进行优化。最后一点，程序分析也有可能用于系统测试和程序调试中。当系统跟踪起来比较复杂，而某个BUG又比较难找时，可以通过一些特殊的数据构造一个测试用例，然后将分析到的函数调用关系和运行时实际的函数调用关系进行对比，从而找出错误代码的位置。</p>
<p>程序分析工具不同于调试器，它只产生程序运行时某些函数的调用次数、执行时间等等宏观信息，而不是每条语句执行时的详细信息。Gprof是Linux下一个强有力的程序分析工具。对于C、Pascal或者Fortran77语 言的程序，它能够以“日志”的形式记录程序运行时的统计信息：程序运行中各个函数消耗的时间和函数调用关系，以及每个函数被调用的次数等等。从而可以帮助 程序员找出众多函数中耗时最多的函数，也可以帮助程序员分析程序的运行流程。相信这些功能对于分析开源代码的程序员来说，有着相当大的诱惑力。</p>
<h2 id="用gprof分析程序"><a href="#用gprof分析程序" class="headerlink" title="用gprof分析程序"></a>用gprof分析程序</h2><p>用gprof对程序进行分析主要分以下三个步骤：</p>
<p>l 用编译器对程序进行编译，加上-pg参数。</p>
<p>l 运行编译后的程序。</p>
<p>l 用gprof命令查看程序的运行时信息。</p>
<p>先以一个简单的例子演示一下吧。随便找一个能够运行的程序的源代码，比如下面的文件test.c：</p>
<p> 1<br> 2 int IsEven(int x)<br> 3<br> 4 {<br> 5<br> 6 return0== x &1;<br> 7<br> 8 }<br> 9<br>10 int main(int argc, char*argv[]<br>11<br>12 {<br>13<br>14 int i =0;<br>15<br>16 while(++i &lt;1000) IsEven(i);<br>17<br>18 }</p>
<p>首先，用以下命令进行编译：</p>
<p> [root@localhost]#gcc –o test –pg test.c</p>
<p>然后，运行可执行文件test.</p>
<p> [root@localhost]#./test</p>
<p>运行后，在当前目录下将生成一个文件gmon.out，这就是gprof生成的文件，保存有程序运行期间函数调用等信息。</p>
<p>最后，用gprof命令查看gmon.out保存的信息：</p>
<p> [root@localhost]#gprof test gmon.out –b</p>
<p>这样就有一大堆信息输出到屏幕上，有函数执行单间，函数调用关系图等等，如下：</p>
<p>Flat profile:</p>
<p>Each sample counts as 0.01 seconds.</p>
<p>no time accumulated</p>
<p> % cumulative self self total</p>
<p>time seconds seconds calls Ts/call Ts/call name</p>
<p> 0.00 0.00 0.00 1000 0.00 0.00 IsEven(int)</p>
<p> Call graph</p>
<p>granularity: each sample hit covers 2 byte(s) no time propagated</p>
<p>index % time self children called name</p>
<p> 0.00 0.00 1000/1000 main [7]</p>
<p>[8] 0.0 0.00 0.00 1000 IsEven(int) [8]</p>
<p>-----------------------------------------------</p>
<p>Index by function name</p>
<p> [8] IsEven(int)</p>
<p>以上介绍了gprof最简单的使用方法，下面针对其使用过程中的三个步骤详细说明。</p>
<h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p>上面的例子中，程序比较简单，只有一个文件。如果源代码有多个文件，或者代码结构比较复杂，编译过程中先生成若干个目标文件，然后又由链接器将这些目标文件链接到一起，这时该怎么使用gprof呢？</p>
<p>对于由多个源文件组成的程序，编译时需要在生成每个.o文件的时候加上-pg参数，同时在链接的时候也要加上-pg参数。对于链接器不是GCC的情况，如ld，又有特殊的要求。</p>
<p>同时，-pg参数只能记录源代码中各个函数的调用关系，而不能记录库函数的调用情况。要想记录每个库函数的调用情况，链接的时候必须指定库函数的动态（或者静态）链接库libc_p.a，即加上-lc_p，而不是-lc。</p>
<p>还要说明的是，如果有一部分代码在编译时指定了-pg参数，而另一部分代码没有指定，则生成的gmon.out文件中将缺少一部分函数，也没有那些函数的调用关系。但是并不影响gprof对其它函数进行记录。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>编译好的程序运行时和运行一般的程序没有什么不同，只是比正常的程序多生成了一个文件gmon.out。注意，这个文件名是固定的，没法通过参数的设置进行改变。如果程序目录中已经有一个gmon.out，则它会被新的gmon.out覆盖掉。</p>
<p>关于生成的gmon.out文件所在的目录，也有以下约定：程序退出时所运行的文件所在目录就是生成的gmon.out文件所在的目录。如果一个程序执行过程中调用了另一个程序，并在另一个程序的运行中终止，则gmon.out会在另一个程序所在的目录中生成。</p>
<p>还有一点要注意的就是当程序非正常终止时不会生成gmon.out文件，也因此就没法查看程序运行时的信息。只有当程序从main函数中正常退出，或者通过系统调用exit()函数而退出时，才会生成gmon.out文件。而通过底层调用如_exit()等退出时不会生成gmon.out。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看程序运行信息的命令是gprof，它以gmon.out文件作为输入，也就是将gmon.out文件翻译成可读的形式展现给用户。其命令格式如下：</p>
<p> gprof [可执行文件] [gmon.out文件] [其它参数]</p>
<p>方括号中的内容可以省略。如果省略了“可执行文件”，gprof会在当前目录下搜索a.out文件作为可执行文件，而如果省略了gmon.out文件，gprof也会在当前目录下寻找gmon.out。其它参数可以控制gprof输出内容的格式等信息。最常用的参数如下：</p>
<p>l -b 不再输出统计图表中每个字段的详细描述。</p>
<p>l -p 只输出函数的调用图（Call graph的那部分信息）。</p>
<p>l -q 只输出函数的时间消耗列表。</p>
<p>l -e Name 不再输出函数Name 及其子函数的调用图（除非它们有未被限制的其它父函数）。可以给定多个 -e 标志。一个 -e 标志只能指定一个函数。</p>
<p>l -E Name 不再输出函数Name 及其子函数的调用图，此标志类似于 -e 标志，但它在总时间和百分比时间的计算中排除了由函数Name 及其子函数所用的时间。</p>
<p>l -f Name 输出函数Name 及其子函数的调用图。可以指定多个 -f 标志。一个 -f 标志只能指定一个函数。</p>
<p>l -F Name 输出函数Name 及其子函数的调用图，它类似于 -f 标志，但它在总时间和百分比时间计算中仅使用所打印的例程的时间。可以指定多个 -F 标志。一个 -F 标志只能指定一个函数。-F 标志覆盖 -E 标志。</p>
<p>l -z 显示使用次数为零的例程（按照调用计数和累积时间计算）。</p>
<p>不过,gprof不能显示对象之间的继承关系,这也是它的弱点.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://q1.qlogo.cn/g?b=qq&nk=493654134&s=5"
                alt="haitian" />
            
              <p class="site-author-name" itemprop="name">haitian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">278</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">164</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/suchalin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:suchalin@126.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haitian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
